<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>zstd 1.4.8 中文手册</title>
</head>
<body>
<h1>zstd 1.4.8 中文手册</h1>
<hr>
<a name="Contents"></a><h2>目录</h2>
<ol>
<li><a href="#Chapter1">简介</a></li>
<li><a href="#Chapter2">版本</a></li>
<li><a href="#Chapter3">简单 API</a></li>
<li><a href="#Chapter4">明确上下文</a></li>
<li><a href="#Chapter5">高级压缩 API</a></li>
<li><a href="#Chapter6">高级解压 API</a></li>
<li><a href="#Chapter7">数据流</a></li>
<li><a href="#Chapter8">数据流压缩 - HowTo</a></li>
<li><a href="#Chapter9">数据流解压 - HowTo</a></li>
<li><a href="#Chapter10">简单字典 API</a></li>
<li><a href="#Chapter11">批量处理字典 API</a></li>
<li><a href="#Chapter12">字典辅助函数</a></li>
<li><a href="#Chapter13">高级字典和前缀 API</a></li>
<li><a href="#Chapter14">实验性 API (仅静态链接)</a></li>
<li><a href="#Chapter15">帧大小函数</a></li>
<li><a href="#Chapter16">内存管理</a></li>
<li><a href="#Chapter17">高级压缩函数</a></li>
<li><a href="#Chapter18">高级解压函数</a></li>
<li><a href="#Chapter19">高级数据流函数</a></li>
<li><a href="#Chapter20">无缓冲区和同步的内部数据流函数</a></li>
<li><a href="#Chapter21">无缓冲区数据流压缩 (同步模式)</a></li>
<li><a href="#Chapter22">无缓冲区数据流解压 (同步模式)</a></li>
<li><a href="#Chapter23">区块级 API</a></li>
</ol>
<hr>
<a name="Chapter1"></a><h2>简介</h2><pre>
  zstd 是 Zstandard 的简称，是一种快速无损压缩算法，针对 zlib 级的实时压缩场景，压缩比更好。
  zstd 压缩库提供了内存压缩和解压功能。

  该库支持从 1 到 ZSTD_maxCLevel() 的常规压缩级别。
  目前是22。级别 >= 20，标注为 `--ultra`，应谨慎使用，因为它们需要更多的内存。
  该库还提供了负压缩级别，扩大了速度与比率的范围。级别越低，速度越快（以压缩为代价）。

  压缩可以用：
    - 单一步骤 (称为：简单 API)
    - 单一步骤，重复使用上下文 （称为：明确上下文）
    - 无限多步 (称为：数据流压缩)

  使用字典可以极大地提高对小数据的压缩率。字典压缩可以：
    - 单一步骤 (称为： 简单字典 API)
    - 单一步骤，复用字典 (称为： 批量处理字典 API)

  高级实验函数可以在包含 zstd.h 之前使用 `#define ZSTD_STATIC_LINKING_ONLY` 来访问。

  高级实验性 API 永远不应该与动态链接库一起使用。它们并不稳定；
  它们的定义或签名可能在未来发生变化，只允许静态链接。
<BR></pre>

<a name="Chapter2"></a><h2>版本</h2><pre></pre>

<pre><b>unsigned ZSTD_versionNumber(void);
</b><p>  返回运行时库的版本，值为 (MAJOR*100*100 + MINOR*100 + RELEASE).
</p></pre><BR>

<pre><b>const char* ZSTD_versionString(void);
</b><p>  返回运行时库的版本， 如 "1.4.5". 需要 v1.3.0+.
</p></pre><BR>

<a name="Chapter3"></a><h2>简单 API</h2><pre></pre>

<pre><b>size_t ZSTD_compress( void* dst, size_t dstCapacity,
                const void* src, size_t srcSize,
                      int compressionLevel);
</b><p>  将 `src` 内容作为一个单一的 zstd 压缩帧压缩到已经分配的 `dst` 中。
  提示：如果 `dstCapacity` >= `ZSTD_compressBound(srcSize)`，压缩运行更快。
  @return : 压缩后写入 `dst` 的大小 (<= `dstCapacity`)。
            或者如果失败了，则是一个错误代码 （可以使用 ZSTD_isError() 来测试）。
</p></pre><BR>

<pre><b>size_t ZSTD_decompress( void* dst, size_t dstCapacity,
                  const void* src, size_t compressedSize);
</b><p>  `compressedSize` : 必须是一些被压缩或可跳过的帧的确切大小。
  `dstCapacity` 是要重新生成的原始大小的上界。
  如果用户不能提供一个最大的上界，最好使用数据流模式来解压数据。
  @return : 解压到 `dst` 的字节数（<= `dstCapacity`）。
            或者如果失败的话，则是一个错误代码 (可以使用 ZSTD_isError() 来测试)。
</p></pre><BR>

<pre><b>#define ZSTD_CONTENTSIZE_UNKNOWN (0ULL - 1)
#define ZSTD_CONTENTSIZE_ERROR   (0ULL - 2)
unsigned long long ZSTD_getFrameContentSize(const void *src, size_t srcSize);
</b><p>  `src`应指向一个ZSTD编码帧的开始。
  `srcSize`必须至少和帧头一样大。
            提示：任何尺寸 >= `ZSTD_frameHeaderSize_max` 都足够大。
  @return : - `src` 帧内容的解压大小，如果知道的话。
            - ZSTD_CONTENTSIZE_UNKNOWN，如果不能确定大小。
            - ZSTD_CONTENTSIZE_ERROR 如果发生错误 (例如无效的数字，srcSize 太小)
   注1：返回值为 0 表示该帧有效，但为 "空"。
   注2：解压大小是一个可选的字段，它可能不存在，通常在数据流模式下。
            当 `return == ZSTD_CONTENTSIZE_UNKNOWN` 时，要解压的数据可以是任何大小。
            在这种情况下，就需要使用数据流模式来解压数据。也可以选择，应用程序可以依靠一些隐含的限制。
            因为 ZSTD_decompress() 只需要一个解压大小的上界。(例如，数据可以一定被切成 <= 16 KB的块)。
   注3：当使用单通道函数完成压缩时，解压大小总是存在的。
            如 ZSTD_compress()、ZSTD_compressCCtx() ZSTD_compress_usingDict() 或 ZSTD_compress_usingCDict()。
   注4：解压后的大小可能会非常大(64-bits的值)。
            潜在地大于本地系统所能处理的单个内存段。
            在这种情况下，就需要使用数据流模式来解压数据。
   注5：如果源是不受信任的，解压大小可能是错误的，或者是故意修改的。
            始终确保返回值符合应用程序的授权限制。每个应用程序可以设置自己的限制。
   注6：这个函数取代了 ZSTD_getDecompressedSize()。
</p></pre><BR>

<pre><b>unsigned long long ZSTD_getDecompressedSize(const void* src, size_t srcSize);
</b><p>  注意：这个函数现在已经过时了，取而代之的是ZSTD_getFrameContentSize()。
  两个函数的工作方式相同，但是 ZSTD_getDecompressedSize() 混合了
  "空"、"未知 "和 "错误 "的结果是相同的返回值（0）。
  而 ZSTD_getFrameContentSize() 则给它们单独的返回值。
  @return : `src`帧内容的解压大小 _如果已知且不为空_，否则为 0。
</p></pre><BR>

<pre><b>size_t ZSTD_findFrameCompressedSize(const void* src, size_t srcSize);
</b><p>  `src`应指向一个 ZSTD 帧或可跳过帧的开始。
  `srcSize`必须 >= 第一个帧的大小。
  @return：从`src`开始的第一帧的压缩大小。
          适合作为 `srcSize' 传递给 `ZSTD_decompress' 或类似产品。
          如果输入无效，则显示错误代码
</p></pre><BR>

<h3>辅助函数</h3><pre></pre><b><pre>#define ZSTD_COMPRESSBOUND(srcSize)   ((srcSize) + ((srcSize)>>8) + (((srcSize) < (128<<10)) ? (((128<<10) - (srcSize)) >> 11) : 0))</b>
                                                  /* 只要 A 和 B >= 128KB 该公式确保 bound(A) + bound(B) <= bound(A+B) */<b>
size_t      ZSTD_compressBound(size_t srcSize); </b>/*!< 在最差情况下，单次最大压缩大小 */<b>
unsigned    ZSTD_isError(size_t code);          </b>/*!< 判断函数返回结果 `size_t` 是否为错误代码 */<b>
const char* ZSTD_getErrorName(size_t code);     </b>/*!< 从错误代码中提供可读字符串 */<b>
int         ZSTD_minCLevel(void);               </b>/*!< 允许的最小负压缩水平 */<b>
int         ZSTD_maxCLevel(void);               </b>/*!< 最大可用压缩级别 */<b>
</pre></b><BR>
<a name="Chapter4"></a><h2>明确上下文</h2><pre></pre>

<h3>压缩上下文</h3><pre>  当压缩多次，建议只分配一次上下文，
  并在每次连续的压缩操作中重新使用它，这将使工作负载对系统的内存更友好。
  注意1：重新使用上下文只是一种速度/资源优化，它不会改变压缩率，压缩率保持不变。
  注意2：在多线程环境下，每个线程使用一个不同的上下文进行并行执行。

</pre><b><pre>typedef struct ZSTD_CCtx_s ZSTD_CCtx;
ZSTD_CCtx* ZSTD_createCCtx(void);
size_t     ZSTD_freeCCtx(ZSTD_CCtx* cctx);
</pre></b><BR>
<pre><b>size_t ZSTD_compressCCtx(ZSTD_CCtx* cctx,
                         void* dst, size_t dstCapacity,
                   const void* src, size_t srcSize,
                         int compressionLevel);
</b><p>  和 ZSTD_compress() 一样，使用一个显式的 ZSTD_CCtx
  重要的是：为了与 `ZSTD_compress()` 表现相似
  该函数按要求的压缩级别进行压缩
  __忽略任何其他参数__
  如果使用高级API设置了任何高级参数
  它们都将被重置，只有 `compressionLevel` 会被保留

</p></pre><BR>

<h3>解压上下文</h3><pre>  当解压多次，建议一个上下文只分配一次。
  并在每次连续的压缩操作中重新使用它。
  这将使工作负载对系统的内存更友好。
  每个线程使用一个上下文进行并行执行。
</pre><b><pre>typedef struct ZSTD_DCtx_s ZSTD_DCtx;
ZSTD_DCtx* ZSTD_createDCtx(void);
size_t     ZSTD_freeDCtx(ZSTD_DCtx* dctx);
</pre></b><BR>
<pre><b>size_t ZSTD_decompressDCtx(ZSTD_DCtx* dctx,
                           void* dst, size_t dstCapacity,
                     const void* src, size_t srcSize);
</b><p>  与 ZSTD_decompress() 相同，
  需要分配一个 ZSTD_DCtx，与粘性参数兼容。

</p></pre><BR>

<a name="Chapter5"></a><h2>高级压缩 API</h2><pre></pre>

<pre><b>typedef enum { ZSTD_fast=1,
               ZSTD_dfast=2,
               ZSTD_greedy=3,
               ZSTD_lazy=4,
               ZSTD_lazy2=5,
               ZSTD_btlazy2=6,
               ZSTD_btopt=7,
               ZSTD_btultra=8,
               ZSTD_btultra2=9
               </b>/* 注：未来可能会增加新的策略，只保证顺序（从快到强） */<b>
} ZSTD_strategy;
</b></pre><BR>
<pre><b>typedef enum {

    </b>/* 压缩 ZSTD_compressionParameters (压缩参数)
     * 注意：当使用 ZSTD_CDict 压缩时，这些参数将被取代
     * 由用于构造 ZSTD_CDict 的参数决定
     * 更多信息请参见 ZSTD_CCtx_refCDict() (superseded-by-cdict). */<b>
    ZSTD_c_compressionLevel=100,</b>/* 根据预先定义的 cLevel 表设置压缩参数
                                  * 注意，确切的压缩参数是动态确定的
                                  * 取决于压缩级别和 srcSize（已知时）
                                  * 默认级别是 ZSTD_CLEVEL_DEFAULT==3
                                  * 特殊情况：值 0 表示默认，由 ZSTD_CLEVEL_DEFAULT 控制
                                  * 注1 : 可以通过负压缩级别
                                  * 注2 : 设置一个级别并不会自动设置所有其他压缩参数
                                  *   设置为默认值。 但是，设置这个等级最终会动态地影响那些没有手动设置的压缩参数
                                  *   手动设置的那些会 'stick' */
    /* 高级压缩参数 :
     * 可以将压缩参数固定为一些特定的值，在这种情况下，压缩器不再动态地选择这些值 */<b>
    ZSTD_c_windowLog=101,   </b>/* 允许的最大反向参考距离，用2的幂表示
                              * 这将设置数据流解压缩的内存预算,
                              * 较大的数值需要更多的内存，而且通常压缩得更多
                              * 必须控制在 ZSTD_WINDOWLOG_MIN 和ZSTD_WINDOWLOG_MAX 之间
                              * 特殊：值 0 表示 "使用默认的 windowLog"
                              * 注意：使用大于 ZSTD_WINDOWLOG_LIMIT_DEFAULT 的 windowLog
                              *       需要在数据流解压缩阶段明确允许这种大小 */<b>
    ZSTD_c_hashLog=102,
                             </b>/* 初始探测表的大小，为2的幂
                              * 结果内存使用量为 (1 << (hashLog+2))
                              * 必须介于 ZSTD_HASHLOG_MIN 和 ZSTD_HASHLOG_MAX之间
                              * 较大的表可以提高策略的压缩比 <= dFast,
                              * 并提高策略的速度 > dFast
                              * 特别：值 0 表示 "使用默认的 hashLog" */<b>
    ZSTD_c_chainLog=103,    </b>/* 多探针搜索表的大小，2的幂。
                              * 结果内存使用量为 (1 << (chainLog+2))
                              * 必须介于 ZSTD_CHAINLOG_MIN 和ZSTD_CHAINLOG_MAX 之间
                              * 表越大，压缩效果越好，速度越慢
                              * 这个参数对于 "fast" 策略是没有用的
                              * 当使用 "dfast" 策略时，这个参数仍然有用
                              * 在这种情况下，它定义了一个二级探针表。
                              * 特别：值 0 表示 "使用默认的 chainLog" */<b>
    ZSTD_c_searchLog=104,   </b>/* 搜索尝试的次数，是2的幂
                              * 尝试次数越多，压缩效果越好，速度越慢
                              * 这个参数对于 "fast" 和 "dFast" 策略没有用
                              * 特殊：值 0 表示 "使用默认的 searchLog" */<b>
    ZSTD_c_minMatch=105,    </b>/* 搜索到的匹配项的最小尺寸
                              * 注意，Zstandard 仍然可以找到较小尺寸的匹配
                              * 它只是调整其搜索算法来寻找这个尺寸和更大的尺寸
                              * 较大的值会增加压缩和解压速度，但会降低比率
                              * 必须介于 ZSTD_MINMATCH_MIN 和ZSTD_MINMATCH_MAX 之间
                              * 注意，目前对于所有策略 < btopt，有效最小值为 4
                              * 对于所有 > fast 的策略，有效的最大值是 6
                              * 特殊：值 0 表示 "使用默认的 minMatchLength" */<b>
    ZSTD_c_targetLength=106,</b>/* 该字段的影响取决于策略
                              * 对于策略 btop、btultra 和 btultra2：
                              *     匹配的长度被认为 "足够好" 而停止搜索.
                              *     值越大，压缩越强，速度越慢
                              * 对于 fast 策略：
                              *     匹配采样之间的距离
                              *     值越大，压缩越快，比率越小
                              * 特殊：值 0 表示 "使用默认的targetLength" */<b>
    ZSTD_c_strategy=107,    </b>/* 参见 ZSTD_strategy 枚举定义
                              * 所选策略的值越高，越复杂
                              * 导致压缩更强，速度更慢
                              * 特别：值 0 表示 "使用默认 strategy" */<b>

    </b>/* LDM 模式参数 */<b>
    ZSTD_c_enableLongDistanceMatching=160,
                             </b>/* 启用长距离匹配
                              * 此参数是为了提高压缩比而设计的
                              * 对于大的输入，通过在远距离寻找大的匹配
                              * 它增加了内存使用和窗口大小
                              * 注意：启用该参数会使默认的 ZSTD_c_windowLog 增加到128 MB
                              * 除非明确设置了不同的值
                              * 注意：如果 ZSTD_c_windowLog >= 128 MB 且
                              * 压缩策略 >= ZSTD_btopt (压缩级别16+)，则默认启用 */<b>
    ZSTD_c_ldmHashLog=161,  </b>/* 长距离匹配表的大小，为2的幂
                              * 值越大，内存使用量和压缩比率越大
                              * 但会降低压缩速度
                              * 必须介于 ZSTD_HASHLOG_MIN和ZSTD_HASHLOG_MAX 之间
                              * 默认：windowlog - 7。
                              * 特殊：值 0 表示 "自动确定 hashlog" */<b>
    ZSTD_c_ldmMinMatch=162, </b>/* 长距离匹配的最小匹配大小
                              * 太大或太小的值通常会降低压缩比率
                              * 必须介于 ZSTD_LDM_MINMATCH_MIN 和 ZSTD_LDM_MINMATCH_MAX 之间
                              * 特殊：值 0 表示 "使用默认值"（默认值：64） */<b>
    ZSTD_c_ldmBucketSizeLog=163,
                             </b>/* LDM 哈希表中每个 Bucket 的对数大小，用于解决碰撞问题
                              * 较大的值可以提高碰撞分辨率，但会降低压缩速度
                              * 最大值是 ZSTD_LDM_BUCKETSIZELOG_MAX
                              * 特殊：值 0 表示 "使用默认值"（默认值：3） */<b>
    ZSTD_c_ldmHashRateLog=164,
                             </b>/* 在 LDM 哈希表中插入 / 查找条目的频率
                              * 必须介于 0 和 (ZSTD_WINDOWLOG_MAX - ZSTD_HASHLOG_MIN).
                              * 默认值是 MAX(0, (windowLog - ldmHashLog))，优化哈希表的使用
                              * 值越大，压缩速度越快
                              * 如果远远偏离默认值，很可能会导致压缩率下降
                              * 特殊：值 0 表示 "自动确定hashRateLog" */<b>

    </b>/* 帧参数 */<b>
    ZSTD_c_contentSizeFlag=200,
                             </b>/* 内容大小将被写入帧头 _whenever known_ (默认:1)
                              * 内容大小必须在压缩开始时就知道
                              * 当使用 ZSTD_compress2() 时，会自动知道内容大小
                              * 对于数据流方案，必须用ZSTD_CCtx_setPledgedSrcSize() 提供内容大小 */<b>
    ZSTD_c_checksumFlag=201,</b>/* 32-bits 的内容校验和被写入到帧尾（默认：0） */<b>
    ZSTD_c_dictIDFlag=202,  </b>/* 当适用时，字典的ID被写入帧头（默认：1） */<b>

    </b>/* 多线程参数 */<b>
    </b>/* 这些参数只有在启用多线程的情况下才会被激活（用编译宏 ZSTD_MULTITHREAD 编译）
     * 否则，试图设置默认值 (0) 以外的任何其他值都是不可能的，并返回一个错误
     * 在不知道链接库是否支持多线程的情况下
     * 将 ZSTD_c_nbWorkers 设置为任何 >=1 的值，并查看返回值，可以快速检查该属性
     */<b>
    ZSTD_c_nbWorkers=400,   </b>/* 选择产生多少个线程来并行压缩
                              * 当 nbWorkers >= 1 时，当调用 ZSTD_compressStream*() 时触发异步模式
                              * ZSTD_compressStream*() 会消耗输入并尽可能地刷新输出，但会立即将控制权还给调用者
                              * 而压缩是在工作线程中并行进行的
                              * (注意：这个规则的一个强烈的例外是当第一次调用ZSTD_compressStream2() 设置 ZSTD_e_end 时
                              * 在这种情况下，ZSTD_compressStream2()  委托给 ZSTD_compress2()，而 ZSTD_compress2() 总是一个阻塞调用）
                              * 更多的 workers 提高了速度，但也增加了内存使用量
                              * 默认值是 `0`，也就是 "单线程模式"：不产生任何 worker
                              * 压缩是在 Caller 的线程中进行的，所有的调用都是阻塞的 */<b>
    ZSTD_c_jobSize=401,     </b>/* 压缩作业的大小，只有当 nbWorkers >= 1 时，这个值才会被强制执行
                              * 每个压缩作业都是并行完成的，所以这个值会间接影响活动线程的数量。
                              * 0 表示默认值，该值根据压缩参数动态确定
                              * 作业大小必须是重叠大小的最小值，或 1MB，以最大值为准
                              * 最小尺寸是自动透明地执行的 */<b>
    ZSTD_c_overlapLog=402,  </b>/* 控制重叠大小，作为窗口大小的一部分
                              * 重叠大小是指在新作业开始时，从上一个作业重新加载的数据量
                              * 当每个作业被并行压缩时，它有助于保持压缩率
                              * 该值仅在 nbWorkers >= 1 时执行
                              * 该值越大，压缩比率越高，但速度越低
                              * 可能的值范围是0到9：
                              * - 0 表示 "默认值"：该值将由库决定，取决于策略
                              * - 1 表示 "无重叠"。
                              * - 9 表示 "完全重叠"，使用全窗口大小。
                              * 每一个中间等级增加/减少一个系数2的负荷大小。
                              * 9：全窗口；8：w/2；7：w/4；6：w/8；5：w/16；4：w/32；3：w/64；2：w/128；1：无重叠；0：默认
                              * 默认值在6和9之间，取决于策略 */<b>

    </b>/* 注意：也可提供其他实验参数
     * 在API的实验部分
     * 在编写本报告时，它们包括 :
     * ZSTD_c_rsyncable
     * ZSTD_c_format
     * ZSTD_c_forceMaxWindow
     * ZSTD_c_forceAttachDict
     * ZSTD_c_literalCompressionMode
     * ZSTD_c_targetCBlockSize
     * ZSTD_c_srcSizeHint
     * ZSTD_c_enableDedicatedDictSearch
     * ZSTD_c_stableInBuffer
     * ZSTD_c_stableOutBuffer
     * ZSTD_c_blockDelimiters
     * ZSTD_c_validateSequences
     * 因为它们不稳定，所以需要定义ZSTD_STATIC_LINKING_ONLY 来访问它们
     * 注意：千万不要直接使用 experimentalParam 的名字
     *      另外，枚举值本身也是不稳定的，仍然可能改变
     */<b>
     ZSTD_c_experimentalParam1=500,
     ZSTD_c_experimentalParam2=10,
     ZSTD_c_experimentalParam3=1000,
     ZSTD_c_experimentalParam4=1001,
     ZSTD_c_experimentalParam5=1002,
     ZSTD_c_experimentalParam6=1003,
     ZSTD_c_experimentalParam7=1004,
     ZSTD_c_experimentalParam8=1005,
     ZSTD_c_experimentalParam9=1006,
     ZSTD_c_experimentalParam10=1007,
     ZSTD_c_experimentalParam11=1008,
     ZSTD_c_experimentalParam12=1009
} ZSTD_cParameter;
</b></pre><BR>
<pre><b>typedef struct {
    size_t error;
    int lowerBound;
    int upperBound;
} ZSTD_bounds;
</b></pre><BR>
<pre><b>ZSTD_bounds ZSTD_cParam_getBounds(ZSTD_cParameter cParam);
</b><p>  所有参数必须属于一个有下限和上限的区间，否则它们会触发一个错误或被自动夹紧
  @return : 一个 ZSTD_bounds 结构体，其中包含了
         - 一个错误状态字段，必须使用 ZSTD_isError() 测试
         - 下限和上限，包括在内

</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_setParameter(ZSTD_CCtx* cctx, ZSTD_cParameter param, int value);
</b><p>  设置一个压缩参数，由 enum ZSTD_cParameter 选择
  所有的参数都具有有效的边界，可以使用 ZSTD_cParam_getBounds() 查询边界
  提供一个超出边界的值将会限制它，或者触发一个错误（取决于参数）
  一般来说，只有在帧初始化的时候（开始压缩之前）才可以设置参数
  例外情况：当使用多线程模式时（nbWorkers >= 1）
              以下参数可以在压缩过程中更新（在同一帧内）
              => 压缩级别、哈希值、链值、搜索值、minMatch、目标长度和策略
              新的参数只在下一个作业中有效（在 flush() 之后）
 @return : 一个错误代码 (可以使用 ZSTD_isError() 来测试)

</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_setPledgedSrcSize(ZSTD_CCtx* cctx, unsigned long long pledgedSrcSize);
</b><p>  要压缩成单帧的总输入数据大小
  该值将被写入帧头，除非使用 ZSTD_c_contentSizeFlag 明确禁止
  这个值也会在帧结束时被控制，如果不被遵守，会触发一个错误
 @result : 0，或者一个错误代码 (可以用 ZSTD_isError() 测试)
  注1 : pledgedSrcSize==0 实际上意味着 0，也就是一个空帧
           为了表示 "未知内容大小"，传递常量 ZSTD_CONTENTSIZE_UNKNOWN
           ZSTD_CONTENTSIZE_UNKNOWN 是任何新帧的默认值
  注2 : pledgedSrcSize 只对下一帧有效一次
           它在帧结束时被丢弃，并由 ZSTD_CONTENTSIZE_UNKNOWN 代替
  注3 : 每当所有的输入数据在一个回合内提供和消耗时
           例如使用 ZSTD_compress2()
           或立即调用 ZSTD_compressStream2(,,ZSTD_e_end)。
           这个值会自动被 srcSize 覆盖

</p></pre><BR>

<pre><b>typedef enum {
    ZSTD_reset_session_only = 1,
    ZSTD_reset_parameters = 2,
    ZSTD_reset_session_and_parameters = 3
} ZSTD_ResetDirective;
</b></pre><BR>
<pre><b>size_t ZSTD_CCtx_reset(ZSTD_CCtx* cctx, ZSTD_ResetDirective reset);
</b><p>  有2种不同的东西可以被重置，独立或联合：
  - 会话：将停止压缩当前帧，并使 CCtx 准备开始一个新的帧
          在出错后很有用，或者中断任何正在进行的压缩
          任何尚未刷新的内部数据都会被取消
          压缩参数和字典保持不变
          它们将被用于压缩下一帧
          重置会话永远不会失败
  - 参数：将所有参数恢复到 "默认值"
          这也会删除对任何字典的引用
          参数只能在两个会话之间更改（即当前没有进行压缩）
          否则复位失败，函数返回一个错误值(可以使用 ZSTD_isError() 来测试)
  - 两者：类似于重置会话，然后重置参数


</p></pre><BR>

<pre><b>size_t ZSTD_compress2( ZSTD_CCtx* cctx,
                       void* dst, size_t dstCapacity,
                 const void* src, size_t srcSize);
</b><p>  与 ZSTD_compressCCtx() 的行为相同，但压缩参数是用高级API设置的
  ZSTD_compress2() 总是开始一个新的帧
  如果 cctx 保存了之前未完成的帧的数据，那么关于它的一切都会被遗忘
  - 在开始压缩之前，压缩参数会被推送到 CCtx 中，使用ZSTD_CCtx_set*()
  - 该函数始终处于阻塞状态，压缩完成后返回
  提示：如果 `dstCapacity`>= `ZSTD_compressBound(srcSize)`，压缩运行更快
 @return : 压缩后的大小写入`dst` (<= `dstCapacity)。
           如果失败，则返回一个错误代码（可以使用ZSTD_isError() 来测试）

</p></pre><BR>

<a name="Chapter6"></a><h2>高级解压 API</h2><pre></pre>

<pre><b>typedef enum {

    ZSTD_d_windowLogMax=100,</b>/* 选择一个尺寸限制（以2的幂为单位），超过这个限制，则
                              * 数据流 API 将拒绝分配内存缓冲区
                              * 为了保护主机免受不合理的内存需求
                              * 这个参数只有在数据流模式下才有用，因为在单程模式下没有分配内部缓冲区
                              * 默认情况下，解压上下文接受的窗口大小 <= (1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT)
                              * 特殊：值 0 表示 "使用默认的最大windowLog" */<b>

    </b>/* 注意：也可提供其他实验参数
     * 在API的实验部分。
     * 在编写本报告时，它们包括:
     * ZSTD_d_format
     * ZSTD_d_stableOutBuffer
     * ZSTD_d_forceIgnoreChecksum
     * 因为它们不稳定，所以需要定义ZSTD_STATIC_LINKING_ONLY 来访问它们
     * 注意：永远不要直接使用 experimentalParam 的名字
     */<b>
     ZSTD_d_experimentalParam1=1000,
     ZSTD_d_experimentalParam2=1001,
     ZSTD_d_experimentalParam3=1002

} ZSTD_dParameter;
</b></pre><BR>
<pre><b>ZSTD_bounds ZSTD_dParam_getBounds(ZSTD_dParameter dParam);
</b><p>  所有参数必须属于一个有下限和上限的区间
  否则它们会触发一个错误或被自动夹紧
 @return : 一个 ZSTD_bounds 结构体，其中包含了
         - 一个错误状态字段，必须使用 ZSTD_isError() 进行测试
         - 上下限

</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_setParameter(ZSTD_DCtx* dctx, ZSTD_dParameter param, int value);
</b><p>  设置一个压缩参数，由 enum ZSTD_dParameter 选择
  所有的参数都有有效的边界，可以使用ZSTD_dParam_getBounds() 查询边界
  提供一个超出边界的值将会限制它，或者触发一个错误（取决于参数）
  只有在帧初始化时(在开始解压之前)才可以设置一个参数
 返回 : 0，或者一个错误代码(可以用 ZSTD_isError() 来测试)

</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_reset(ZSTD_DCtx* dctx, ZSTD_ResetDirective reset);
</b><p>  重置 DCtx 到干净状态
  会话和参数可以联合或单独复位
  只有当没有活动帧被解压时，参数才能被重置
 返回 : 0，或者一个错误代码，可以用 ZSTD_isError() 测试

</p></pre><BR>

<a name="Chapter7"></a><h2>数据流</h2><pre></pre>

<pre><b>typedef struct ZSTD_inBuffer_s {
  const void* src;    </b>/**< 输入缓冲区的开始 */<b>
  size_t size;        </b>/**< 输入缓冲区的大小 */<b>
  size_t pos;         </b>/**< 读取停止的位置，会被更新。必然是 0 <= pos <= size */<b>
} ZSTD_inBuffer;
</b></pre><BR>
<pre><b>typedef struct ZSTD_outBuffer_s {
  void*  dst;         </b>/**< 输出缓冲区的开始 */<b>
  size_t size;        </b>/**< 输出缓冲区的大小 */<b>
  size_t pos;         </b>/**< 写入停止的位置，会被更新。必然是 0 <= pos <= size */<b>
} ZSTD_outBuffer;
</b></pre><BR>
<a name="Chapter8"></a><h2>数据流压缩 - HowTo</h2><pre>
  需要一个 ZSTD_CStream 对象来跟踪数据流操作
  使用 ZSTD_createCStream() 和 ZSTD_freeCStream() 来创建/释放资源
  ZSTD_CStream 对象可以在连续的压缩操作中重复使用多次
  建议重复使用 ZSTD_CStream，因为它可以重复使用已经分配的内存，从而更好地利用系统的内存

  对于并行执行，每个线程使用一个单独的ZSTD_CStream

  注意：从v1.3.0开始，ZSTD_CStream 和 ZSTD_CCtx 是一回事

  参数是粘性的：当在同一上下文上启动新的压缩时
  它将重新使用与之前压缩会话相同的粘性参数
  当有疑问时，建议在使用前完全初始化上下文
  使用 ZSTD_CCtx_reset() 和 ZSTD_CCtx_setParameter() 来重置上下文
  ZSTD_CCtx_setPledgedSrcSize()，或 ZSTD_CCtx_loadDictionary()
  和其他函数设置更具体的参数，保证源大小，或者加载字典

  使用 ZSTD_compressStream2() 与 ZSTD_e_continue 进行必要的多次操作，以达到以下目的
  消耗输入流，该函数将自动更新 "pos" 和 "input" 和 "output" 中的字段
  请注意，该函数可能不会消耗整个输入，例如：
  因输出缓冲区已经满了，在这种情况下，`input.pos < input.size`
  调用者必须检查输入是否已经全部消耗完毕
  如果没有，调用者必须腾出一些空间来接收更多的压缩数据
  然后再呈现剩余的输入数据
   注意：ZSTD_e_continue 被调用时，保证会有一定的前进速度
        但并不能保证最大限度的向前发展，这一点尤为重要
        这一点在使用多个线程进行压缩时尤为重要
        如果能消耗一些输入，调用不会阻塞
        但如果不能，它将等待一些（但不是全部）输出被刷新
  @return : 提供了从内部缓冲区刷新数据的最小剩余量，
           或错误代码，可以使用 ZSTD_isError() 进行测试

  在任何时候，它都有可能冲洗任何可能停留在内部缓冲区的数据
  使用 ZSTD_compressStream2() 和 ZSTD_e_flush`output->pos`将被更新
  注意，如果 `output->size` 太小，用 ZSTD_e_flush 调用一次可能就不够了(返回代码>0)
  在这种情况下，腾出一些空间来接收更多的压缩数据，然后用 ZSTD_e_flush 再次调用 ZSTD_compressStream2()
  你必须继续用 ZSTD_e_flush 调用ZSTD_compressStream2()，直到它返回 0，这时你可以改变运作
  注意：ZSTD_e_flush 会尽可能多地刷新输出，这意味着当使用多线程压缩时，它会阻塞，直到刷新完成或输出缓冲区满为止
  @return : 如果内部缓冲区完全刷新，则为 0
            >0，如果一些数据仍然存在于内部缓冲区中（该值是剩余大小的最小估计值）
            或错误代码，可以使用 ZSTD_isError() 进行测试

  用 ZSTD_e_end 调用 ZSTD_compressStream2() 指示完成一帧
  它将执行刷新并写入帧尾，这是解码器认为一帧完成所必须的
  flush 操作与调用 ZSTD_compressStream2() 和 ZSTD_e_flush 的规则是一样的
  你必须继续用ZSTD_e_end 调用 ZSTD_compressStream2()，直到它返回0，这时你可以自由地开始一个新的帧
  注意 : ZSTD_e_end 会尽可能多地刷新输出，这意味着当使用多线程压缩时，它会阻塞，直到刷新完成或输出缓冲区满为止
  @return : 如果帧完全完成并完全刷新，则返回 0
            >0，如果一些数据仍然存在于内部缓冲区中（该值是剩余大小的最小估计值）
            或错误代码，可以使用 ZSTD_isError() 进行测试.


<BR></pre>

<pre><b>typedef ZSTD_CCtx ZSTD_CStream;  </b>/**< CCtx 和 CStream 现在实际上是同一个对象 (>= v1.3.0) */<b>
</b></pre><BR>
<h3>ZSTD_CStream 管理函数</h3><pre></pre><b><pre>ZSTD_CStream* ZSTD_createCStream(void);
size_t ZSTD_freeCStream(ZSTD_CStream* zcs);
</pre></b><BR>
<h3>数据流压缩函数</h3><pre></pre><b><pre>typedef enum {
    ZSTD_e_continue=0, </b>/* collect more data, encoder decides when to output compressed result, for optimal compression ratio */<b>
    ZSTD_e_flush=1,    </b>/* flush any data provided so far,
                        * it creates (at least) one new block, that can be decoded immediately on reception;
                        * frame will continue: any future data can still reference previously compressed data, improving compression.
                        * note : multithreaded compression will block to flush as much output as possible. */<b>
    ZSTD_e_end=2       </b>/* flush any remaining data _and_ close current frame.
                        * note that frame is only closed after compressed data is fully flushed (return value == 0).
                        * After that point, any additional data starts a new frame.
                        * note : each frame is independent (does not reference any content from previous frame).
                        : note : multithreaded compression will block to flush as much output as possible. */<b>
} ZSTD_EndDirective;
</pre></b><BR>
<pre><b>size_t ZSTD_compressStream2( ZSTD_CCtx* cctx,
                             ZSTD_outBuffer* output,
                             ZSTD_inBuffer* input,
                             ZSTD_EndDirective endOp);
</b><p>  Behaves about the same as ZSTD_compressStream, with additional control on end directive.
  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()
  - Compression parameters cannot be changed once compression is started (save a list of exceptions in multi-threading mode)
  - output->pos must be <= dstCapacity, input->pos must be <= srcSize
  - output->pos and input->pos will be updated. They are guaranteed to remain below their respective limit.
  - endOp must be a valid directive
  - When nbWorkers==0 (default), function is blocking : it completes its job before returning to caller.
  - When nbWorkers>=1, function is non-blocking : it copies a portion of input, distributes jobs to internal worker threads, flush to output whatever is available,
                                                  and then immediately returns, just indicating that there is some data remaining to be flushed.
                                                  The function nonetheless guarantees forward progress : it will return only after it reads or write at least 1+ byte.
  - Exception : if the first call requests a ZSTD_e_end directive and provides enough dstCapacity, the function delegates to ZSTD_compress2() which is always blocking.
  - @return provides a minimum amount of data remaining to be flushed from internal buffers
            or an error code, which can be tested using ZSTD_isError().
            if @return != 0, flush is not fully completed, there is still some data left within internal buffers.
            This is useful for ZSTD_e_flush, since in this case more flushes are necessary to empty all buffers.
            For ZSTD_e_end, @return == 0 when internal buffers are fully flushed and frame is completed.
  - after a ZSTD_e_end directive, if internal buffer is not fully flushed (@return != 0),
            only ZSTD_e_end or ZSTD_e_flush operations are allowed.
            Before starting a new compression job, or changing compression parameters,
            it is required to fully flush internal buffers.

</p></pre><BR>

<pre><b>size_t ZSTD_CStreamInSize(void);    </b>/**< recommended size for input buffer */<b>
</b></pre><BR>
<pre><b>size_t ZSTD_CStreamOutSize(void);   </b>/**< recommended size for output buffer. Guarantee to successfully flush at least one complete compressed block. */<b>
</b></pre><BR>
<pre><b>size_t ZSTD_initCStream(ZSTD_CStream* zcs, int compressionLevel);
</b>/*!<b>
 * Alternative for ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue).
 * NOTE: The return value is different. ZSTD_compressStream() returns a hint for
 * the next read size (if non-zero and not an error). ZSTD_compressStream2()
 * returns the minimum nb of bytes left to flush (if non-zero and not an error).
 */
size_t ZSTD_compressStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output, ZSTD_inBuffer* input);
</b>/*! Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_flush). */<b>
size_t ZSTD_flushStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output);
</b>/*! Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_end). */<b>
size_t ZSTD_endStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output);
</b><p>
     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)
     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);

</p></pre><BR>

<a name="Chapter9"></a><h2>数据流解压 - HowTo</h2><pre>
  A ZSTD_DStream object is required to track streaming operations.
  Use ZSTD_createDStream() and ZSTD_freeDStream() to create/release resources.
  ZSTD_DStream objects can be re-used multiple times.

  Use ZSTD_initDStream() to start a new decompression operation.
 @return : recommended first input size
  Alternatively, use advanced API to set specific properties.

  Use ZSTD_decompressStream() repetitively to consume your input.
  The function will update both `pos` fields.
  If `input.pos < input.size`, some input has not been consumed.
  It's up to the caller to present again remaining data.
  The function tries to flush all data decoded immediately, respecting output buffer size.
  If `output.pos < output.size`, decoder has flushed everything it could.
  But if `output.pos == output.size`, there might be some data left within internal buffers.,
  In which case, call ZSTD_decompressStream() again to flush whatever remains in the buffer.
  Note : with no additional input provided, amount of data flushed is necessarily <= ZSTD_BLOCKSIZE_MAX.
 @return : 0 when a frame is completely decoded and fully flushed,
        or an error code, which can be tested using ZSTD_isError(),
        or any other value > 0, which means there is still some decoding or flushing to do to complete current frame :
                                the return value is a suggested next input size (just a hint for better latency)
                                that will never request more than the remaining frame size.

<BR></pre>

<pre><b>typedef ZSTD_DCtx ZSTD_DStream;  </b>/**< DCtx and DStream are now effectively same object (>= v1.3.0) */<b>
</b></pre><BR>
<h3>ZSTD_DStream 管理函数</h3><pre></pre><b><pre>ZSTD_DStream* ZSTD_createDStream(void);
size_t ZSTD_freeDStream(ZSTD_DStream* zds);
</pre></b><BR>
<h3>数据流压缩函数</h3><pre></pre><b><pre></pre></b><BR>
<pre><b>size_t ZSTD_DStreamInSize(void);    </b>/*!< recommended size for input buffer */<b>
</b></pre><BR>
<pre><b>size_t ZSTD_DStreamOutSize(void);   </b>/*!< recommended size for output buffer. Guarantee to successfully flush at least one complete block in all circumstances. */<b>
</b></pre><BR>
<a name="Chapter10"></a><h2>简单字典 API</h2><pre></pre>

<pre><b>size_t ZSTD_compress_usingDict(ZSTD_CCtx* ctx,
                               void* dst, size_t dstCapacity,
                         const void* src, size_t srcSize,
                         const void* dict,size_t dictSize,
                               int compressionLevel);
</b><p>  Compression at an explicit compression level using a Dictionary.
  A dictionary can be any arbitrary data segment (also called a prefix),
  or a buffer with specified information (see dictBuilder/zdict.h).
  Note : This function loads the dictionary, resulting in significant startup delay.
         It's intended for a dictionary used only once.
  Note 2 : When `dict == NULL || dictSize < 8` no dictionary is used.
</p></pre><BR>

<pre><b>size_t ZSTD_decompress_usingDict(ZSTD_DCtx* dctx,
                                 void* dst, size_t dstCapacity,
                           const void* src, size_t srcSize,
                           const void* dict,size_t dictSize);
</b><p>  Decompression using a known Dictionary.
  Dictionary must be identical to the one used during compression.
  Note : This function loads the dictionary, resulting in significant startup delay.
         It's intended for a dictionary used only once.
  Note : When `dict == NULL || dictSize < 8` no dictionary is used.
</p></pre><BR>

<a name="Chapter11"></a><h2>批量处理字典 API</h2><pre></pre>

<pre><b>ZSTD_CDict* ZSTD_createCDict(const void* dictBuffer, size_t dictSize,
                             int compressionLevel);
</b><p>  When compressing multiple messages or blocks using the same dictionary,
  it's recommended to digest the dictionary only once, since it's a costly operation.
  ZSTD_createCDict() will create a state from digesting a dictionary.
  The resulting state can be used for future compression operations with very limited startup cost.
  ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only.
 @dictBuffer can be released after ZSTD_CDict creation, because its content is copied within CDict.
  Note 1 : Consider experimental function `ZSTD_createCDict_byReference()` if you prefer to not duplicate @dictBuffer content.
  Note 2 : A ZSTD_CDict can be created from an empty @dictBuffer,
      in which case the only thing that it transports is the @compressionLevel.
      This can be useful in a pipeline featuring ZSTD_compress_usingCDict() exclusively,
      expecting a ZSTD_CDict parameter with any data, including those without a known dictionary.
</p></pre><BR>

<pre><b>size_t      ZSTD_freeCDict(ZSTD_CDict* CDict);
</b><p>  Function frees memory allocated by ZSTD_createCDict().
</p></pre><BR>

<pre><b>size_t ZSTD_compress_usingCDict(ZSTD_CCtx* cctx,
                                void* dst, size_t dstCapacity,
                          const void* src, size_t srcSize,
                          const ZSTD_CDict* cdict);
</b><p>  Compression using a digested Dictionary.
  Recommended when same dictionary is used multiple times.
  Note : compression level is _decided at dictionary creation time_,
     and frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no)
</p></pre><BR>

<pre><b>ZSTD_DDict* ZSTD_createDDict(const void* dictBuffer, size_t dictSize);
</b><p>  Create a digested dictionary, ready to start decompression operation without startup delay.
  dictBuffer can be released after DDict creation, as its content is copied inside DDict.
</p></pre><BR>

<pre><b>size_t      ZSTD_freeDDict(ZSTD_DDict* ddict);
</b><p>  Function frees memory allocated with ZSTD_createDDict()
</p></pre><BR>

<pre><b>size_t ZSTD_decompress_usingDDict(ZSTD_DCtx* dctx,
                                  void* dst, size_t dstCapacity,
                            const void* src, size_t srcSize,
                            const ZSTD_DDict* ddict);
</b><p>  Decompression using a digested Dictionary.
  Recommended when same dictionary is used multiple times.
</p></pre><BR>

<a name="Chapter12"></a><h2>字典辅助函数</h2><pre></pre>

<pre><b>unsigned ZSTD_getDictID_fromDict(const void* dict, size_t dictSize);
</b><p>  Provides the dictID stored within dictionary.
  if @return == 0, the dictionary is not conformant with Zstandard specification.
  It can still be loaded, but as a content-only dictionary.
</p></pre><BR>

<pre><b>unsigned ZSTD_getDictID_fromDDict(const ZSTD_DDict* ddict);
</b><p>  Provides the dictID of the dictionary loaded into `ddict`.
  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
  Non-conformant dictionaries can still be loaded, but as content-only dictionaries.
</p></pre><BR>

<pre><b>unsigned ZSTD_getDictID_fromFrame(const void* src, size_t srcSize);
</b><p>  Provides the dictID required to decompressed the frame stored within `src`.
  If @return == 0, the dictID could not be decoded.
  This could for one of the following reasons :
  - The frame does not require a dictionary to be decoded (most common case).
  - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden information.
    Note : this use case also happens when using a non-conformant dictionary.
  - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize < ZSTD_FRAMEHEADERSIZE_MAX`).
  - This is not a Zstandard frame.
  When identifying the exact failure cause, it's possible to use ZSTD_getFrameHeader(), which will provide a more precise error code.
</p></pre><BR>

<a name="Chapter13"></a><h2>高级字典和前缀 API</h2><pre>
 This API allows dictionaries to be used with ZSTD_compress2(),
 ZSTD_compressStream2(), and ZSTD_decompress(). Dictionaries are sticky, and
 only reset with the context is reset with ZSTD_reset_parameters or
 ZSTD_reset_session_and_parameters. Prefixes are single-use.
<BR></pre>

<pre><b>size_t ZSTD_CCtx_loadDictionary(ZSTD_CCtx* cctx, const void* dict, size_t dictSize);
</b><p>  Create an internal CDict from `dict` buffer.
  Decompression will have to use same dictionary.
 @result : 0, or an error code (which can be tested with ZSTD_isError()).
  Special: Loading a NULL (or 0-size) dictionary invalidates previous dictionary,
           meaning "return to no-dictionary mode".
  Note 1 : Dictionary is sticky, it will be used for all future compressed frames.
           To return to "no-dictionary" situation, load a NULL dictionary (or reset parameters).
  Note 2 : Loading a dictionary involves building tables.
           It's also a CPU consuming operation, with non-negligible impact on latency.
           Tables are dependent on compression parameters, and for this reason,
           compression parameters can no longer be changed after loading a dictionary.
  Note 3 :`dict` content will be copied internally.
           Use experimental ZSTD_CCtx_loadDictionary_byReference() to reference content instead.
           In such a case, dictionary buffer must outlive its users.
  Note 4 : Use ZSTD_CCtx_loadDictionary_advanced()
           to precisely select how dictionary content must be interpreted.
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_refCDict(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict);
</b><p>  Reference a prepared dictionary, to be used for all next compressed frames.
  Note that compression parameters are enforced from within CDict,
  and supersede any compression parameter previously set within CCtx.
  The parameters ignored are labled as "superseded-by-cdict" in the ZSTD_cParameter enum docs.
  The ignored parameters will be used again if the CCtx is returned to no-dictionary mode.
  The dictionary will remain valid for future compressed frames using same CCtx.
 @result : 0, or an error code (which can be tested with ZSTD_isError()).
  Special : Referencing a NULL CDict means "return to no-dictionary mode".
  Note 1 : Currently, only one dictionary can be managed.
           Referencing a new dictionary effectively "discards" any previous one.
  Note 2 : CDict is just referenced, its lifetime must outlive its usage within CCtx.
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_refPrefix(ZSTD_CCtx* cctx,
                     const void* prefix, size_t prefixSize);
</b><p>  Reference a prefix (single-usage dictionary) for next compressed frame.
  A prefix is **only used once**. Tables are discarded at end of frame (ZSTD_e_end).
  Decompression will need same prefix to properly regenerate data.
  Compressing with a prefix is similar in outcome as performing a diff and compressing it,
  but performs much faster, especially during decompression (compression speed is tunable with compression level).
 @result : 0, or an error code (which can be tested with ZSTD_isError()).
  Special: Adding any prefix (including NULL) invalidates any previous prefix or dictionary
  Note 1 : Prefix buffer is referenced. It **must** outlive compression.
           Its content must remain unmodified during compression.
  Note 2 : If the intention is to diff some large src data blob with some prior version of itself,
           ensure that the window size is large enough to contain the entire source.
           See ZSTD_c_windowLog.
  Note 3 : Referencing a prefix involves building tables, which are dependent on compression parameters.
           It's a CPU consuming operation, with non-negligible impact on latency.
           If there is a need to use the same prefix multiple times, consider loadDictionary instead.
  Note 4 : By default, the prefix is interpreted as raw content (ZSTD_dct_rawContent).
           Use experimental ZSTD_CCtx_refPrefix_advanced() to alter dictionary interpretation.
</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_loadDictionary(ZSTD_DCtx* dctx, const void* dict, size_t dictSize);
</b><p>  Create an internal DDict from dict buffer,
  to be used to decompress next frames.
  The dictionary remains valid for all future frames, until explicitly invalidated.
 @result : 0, or an error code (which can be tested with ZSTD_isError()).
  Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary,
            meaning "return to no-dictionary mode".
  Note 1 : Loading a dictionary involves building tables,
           which has a non-negligible impact on CPU usage and latency.
           It's recommended to "load once, use many times", to amortize the cost
  Note 2 :`dict` content will be copied internally, so `dict` can be released after loading.
           Use ZSTD_DCtx_loadDictionary_byReference() to reference dictionary content instead.
  Note 3 : Use ZSTD_DCtx_loadDictionary_advanced() to take control of
           how dictionary content is loaded and interpreted.

</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_refDDict(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict);
</b><p>  Reference a prepared dictionary, to be used to decompress next frames.
  The dictionary remains active for decompression of future frames using same DCtx.
 @result : 0, or an error code (which can be tested with ZSTD_isError()).
  Note 1 : Currently, only one dictionary can be managed.
           Referencing a new dictionary effectively "discards" any previous one.
  Special: referencing a NULL DDict means "return to no-dictionary mode".
  Note 2 : DDict is just referenced, its lifetime must outlive its usage from DCtx.

</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_refPrefix(ZSTD_DCtx* dctx,
                     const void* prefix, size_t prefixSize);
</b><p>  Reference a prefix (single-usage dictionary) to decompress next frame.
  This is the reverse operation of ZSTD_CCtx_refPrefix(),
  and must use the same prefix as the one used during compression.
  Prefix is **only used once**. Reference is discarded at end of frame.
  End of frame is reached when ZSTD_decompressStream() returns 0.
 @result : 0, or an error code (which can be tested with ZSTD_isError()).
  Note 1 : Adding any prefix (including NULL) invalidates any previously set prefix or dictionary
  Note 2 : Prefix buffer is referenced. It **must** outlive decompression.
           Prefix buffer must remain unmodified up to the end of frame,
           reached when ZSTD_decompressStream() returns 0.
  Note 3 : By default, the prefix is treated as raw content (ZSTD_dct_rawContent).
           Use ZSTD_CCtx_refPrefix_advanced() to alter dictMode (Experimental section)
  Note 4 : Referencing a raw content prefix has almost no cpu nor memory cost.
           A full dictionary is more costly, as it requires building tables.

</p></pre><BR>

<pre><b>size_t ZSTD_sizeof_CCtx(const ZSTD_CCtx* cctx);
size_t ZSTD_sizeof_DCtx(const ZSTD_DCtx* dctx);
size_t ZSTD_sizeof_CStream(const ZSTD_CStream* zcs);
size_t ZSTD_sizeof_DStream(const ZSTD_DStream* zds);
size_t ZSTD_sizeof_CDict(const ZSTD_CDict* cdict);
size_t ZSTD_sizeof_DDict(const ZSTD_DDict* ddict);
</b><p>  These functions give the _current_ memory usage of selected object.
  Note that object memory usage can evolve (increase or decrease) over time.
</p></pre><BR>

<a name="Chapter14"></a><h2>实验性 API (仅静态链接)</h2><pre>
 The following symbols and constants
 are not planned to join "stable API" status in the near future.
 They can still change in future versions.
 Some of them are planned to remain in the static_only section indefinitely.
 Some of them might be removed in the future (especially when redundant with existing stable functions)

<BR></pre>

<pre><b>typedef struct {
    unsigned int offset;      </b>/* The offset of the match. (NOT the same as the offset code)<b>
                               * If offset == 0 and matchLength == 0, this sequence represents the last
                               * literals in the block of litLength size.
                               */

    unsigned int litLength;   </b>/* Literal length of the sequence. */<b>
    unsigned int matchLength; </b>/* Match length of the sequence. */<b>

                              </b>/* Note: Users of this API may provide a sequence with matchLength == litLength == offset == 0.<b>
                               * In this case, we will treat the sequence as a marker for a block boundary.
                               */

    unsigned int rep;         </b>/* Represents which repeat offset is represented by the field 'offset'.<b>
                               * Ranges from [0, 3].
                               *
                               * Repeat offsets are essentially previous offsets from previous sequences sorted in
                               * recency order. For more detail, see doc/zstd_compression_format.md
                               *
                               * If rep == 0, then 'offset' does not contain a repeat offset.
                               * If rep > 0:
                               *  If litLength != 0:
                               *      rep == 1 --> offset == repeat_offset_1
                               *      rep == 2 --> offset == repeat_offset_2
                               *      rep == 3 --> offset == repeat_offset_3
                               *  If litLength == 0:
                               *      rep == 1 --> offset == repeat_offset_2
                               *      rep == 2 --> offset == repeat_offset_3
                               *      rep == 3 --> offset == repeat_offset_1 - 1
                               *
                               * Note: This field is optional. ZSTD_generateSequences() will calculate the value of
                               * 'rep', but repeat offsets do not necessarily need to be calculated from an external
                               * sequence provider's perspective. For example, ZSTD_compressSequences() does not
                               * use this 'rep' field at all (as of now).
                               */
} ZSTD_Sequence;
</b></pre><BR>
<pre><b>typedef struct {
    unsigned windowLog;       </b>/**< largest match distance : larger == more compression, more memory needed during decompression */<b>
    unsigned chainLog;        </b>/**< fully searched segment : larger == more compression, slower, more memory (useless for fast) */<b>
    unsigned hashLog;         </b>/**< dispatch table : larger == faster, more memory */<b>
    unsigned searchLog;       </b>/**< nb of searches : larger == more compression, slower */<b>
    unsigned minMatch;        </b>/**< match length searched : larger == faster decompression, sometimes less compression */<b>
    unsigned targetLength;    </b>/**< acceptable match size for optimal parser (only) : larger == more compression, slower */<b>
    ZSTD_strategy strategy;   </b>/**< see ZSTD_strategy definition above */<b>
} ZSTD_compressionParameters;
</b></pre><BR>
<pre><b>typedef struct {
    int contentSizeFlag; </b>/**< 1: content size will be in frame header (when known) */<b>
    int checksumFlag;    </b>/**< 1: generate a 32-bits checksum using XXH64 algorithm at end of frame, for error detection */<b>
    int noDictIDFlag;    </b>/**< 1: no dictID will be saved into frame header (dictID is only useful for dictionary compression) */<b>
} ZSTD_frameParameters;
</b></pre><BR>
<pre><b>typedef struct {
    ZSTD_compressionParameters cParams;
    ZSTD_frameParameters fParams;
} ZSTD_parameters;
</b></pre><BR>
<pre><b>typedef enum {
    ZSTD_dct_auto = 0,       </b>/* dictionary is "full" when starting with ZSTD_MAGIC_DICTIONARY, otherwise it is "rawContent" */<b>
    ZSTD_dct_rawContent = 1, </b>/* ensures dictionary is always loaded as rawContent, even if it starts with ZSTD_MAGIC_DICTIONARY */<b>
    ZSTD_dct_fullDict = 2    </b>/* refuses to load a dictionary if it does not respect Zstandard's specification, starting with ZSTD_MAGIC_DICTIONARY */<b>
} ZSTD_dictContentType_e;
</b></pre><BR>
<pre><b>typedef enum {
    ZSTD_dlm_byCopy = 0,  </b>/**< Copy dictionary content internally */<b>
    ZSTD_dlm_byRef = 1    </b>/**< Reference dictionary content -- the dictionary buffer must outlive its users. */<b>
} ZSTD_dictLoadMethod_e;
</b></pre><BR>
<pre><b>typedef enum {
    ZSTD_f_zstd1 = 0,           </b>/* zstd frame format, specified in zstd_compression_format.md (default) */<b>
    ZSTD_f_zstd1_magicless = 1  </b>/* Variant of zstd frame format, without initial 4-bytes magic number.<b>
                                 * Useful to save 4 bytes per generated frame.
                                 * Decoder cannot recognise automatically this format, requiring this instruction. */
} ZSTD_format_e;
</b></pre><BR>
<pre><b>typedef enum {
    </b>/* Note: this enum controls ZSTD_d_forceIgnoreChecksum */<b>
    ZSTD_d_validateChecksum = 0,
    ZSTD_d_ignoreChecksum = 1
} ZSTD_forceIgnoreChecksum_e;
</b></pre><BR>
<pre><b>typedef enum {
    </b>/* Note: this enum and the behavior it controls are effectively internal<b>
     * implementation details of the compressor. They are expected to continue
     * to evolve and should be considered only in the context of extremely
     * advanced performance tuning.
     *
     * Zstd currently supports the use of a CDict in three ways:
     *
     * - The contents of the CDict can be copied into the working context. This
     *   means that the compression can search both the dictionary and input
     *   while operating on a single set of internal tables. This makes
     *   the compression faster per-byte of input. However, the initial copy of
     *   the CDict's tables incurs a fixed cost at the beginning of the
     *   compression. For small compressions (< 8 KB), that copy can dominate
     *   the cost of the compression.
     *
     * - The CDict's tables can be used in-place. In this model, compression is
     *   slower per input byte, because the compressor has to search two sets of
     *   tables. However, this model incurs no start-up cost (as long as the
     *   working context's tables can be reused). For small inputs, this can be
     *   faster than copying the CDict's tables.
     *
     * - The CDict's tables are not used at all, and instead we use the working
     *   context alone to reload the dictionary and use params based on the source
     *   size. See ZSTD_compress_insertDictionary() and ZSTD_compress_usingDict().
     *   This method is effective when the dictionary sizes are very small relative
     *   to the input size, and the input size is fairly large to begin with.
     *
     * Zstd has a simple internal heuristic that selects which strategy to use
     * at the beginning of a compression. However, if experimentation shows that
     * Zstd is making poor choices, it is possible to override that choice with
     * this enum.
     */
    ZSTD_dictDefaultAttach = 0, </b>/* Use the default heuristic. */<b>
    ZSTD_dictForceAttach   = 1, </b>/* Never copy the dictionary. */<b>
    ZSTD_dictForceCopy     = 2, </b>/* Always copy the dictionary. */<b>
    ZSTD_dictForceLoad     = 3  </b>/* Always reload the dictionary */<b>
} ZSTD_dictAttachPref_e;
</b></pre><BR>
<pre><b>typedef enum {
  ZSTD_lcm_auto = 0,          </b>/**< Automatically determine the compression mode based on the compression level.<b>
                               *   Negative compression levels will be uncompressed, and positive compression
                               *   levels will be compressed. */
  ZSTD_lcm_huffman = 1,       </b>/**< Always attempt Huffman compression. Uncompressed literals will still be<b>
                               *   emitted if Huffman compression is not profitable. */
  ZSTD_lcm_uncompressed = 2   </b>/**< Always emit uncompressed literals. */<b>
} ZSTD_literalCompressionMode_e;
</b></pre><BR>
<a name="Chapter15"></a><h2>帧大小函数</h2><pre></pre>

<pre><b>unsigned long long ZSTD_findDecompressedSize(const void* src, size_t srcSize);
</b><p>  `src` should point to the start of a series of ZSTD encoded and/or skippable frames
  `srcSize` must be the _exact_ size of this series
       (i.e. there should be a frame boundary at `src + srcSize`)
  @return : - decompressed size of all data in all successive frames
            - if the decompressed size cannot be determined: ZSTD_CONTENTSIZE_UNKNOWN
            - if an error occurred: ZSTD_CONTENTSIZE_ERROR

   note 1 : decompressed size is an optional field, that may not be present, especially in streaming mode.
            When `return==ZSTD_CONTENTSIZE_UNKNOWN`, data to decompress could be any size.
            In which case, it's necessary to use streaming mode to decompress data.
   note 2 : decompressed size is always present when compression is done with ZSTD_compress()
   note 3 : decompressed size can be very large (64-bits value),
            potentially larger than what local system can handle as a single memory segment.
            In which case, it's necessary to use streaming mode to decompress data.
   note 4 : If source is untrusted, decompressed size could be wrong or intentionally modified.
            Always ensure result fits within application's authorized limits.
            Each application can set its own limits.
   note 5 : ZSTD_findDecompressedSize handles multiple frames, and so it must traverse the input to
            read each contained frame header.  This is fast as most of the data is skipped,
            however it does mean that all frame data must be present and valid.
</p></pre><BR>

<pre><b>unsigned long long ZSTD_decompressBound(const void* src, size_t srcSize);
</b><p>  `src` should point to the start of a series of ZSTD encoded and/or skippable frames
  `srcSize` must be the _exact_ size of this series
       (i.e. there should be a frame boundary at `src + srcSize`)
  @return : - upper-bound for the decompressed size of all data in all successive frames
            - if an error occured: ZSTD_CONTENTSIZE_ERROR

  note 1  : an error can occur if `src` contains an invalid or incorrectly formatted frame.
  note 2  : the upper-bound is exact when the decompressed size field is available in every ZSTD encoded frame of `src`.
            in this case, `ZSTD_findDecompressedSize` and `ZSTD_decompressBound` return the same value.
  note 3  : when the decompressed size field isn't available, the upper-bound for that frame is calculated by:
              upper-bound = # blocks * min(128 KB, Window_Size)

</p></pre><BR>

<pre><b>size_t ZSTD_frameHeaderSize(const void* src, size_t srcSize);
</b><p>  srcSize must be >= ZSTD_FRAMEHEADERSIZE_PREFIX.
 @return : size of the Frame Header,
           or an error code (if srcSize is too small)
</p></pre><BR>

<pre><b>typedef enum {
  ZSTD_sf_noBlockDelimiters = 0,         </b>/* Representation of ZSTD_Sequence has no block delimiters, sequences only */<b>
  ZSTD_sf_explicitBlockDelimiters = 1    </b>/* Representation of ZSTD_Sequence contains explicit block delimiters */<b>
} ZSTD_sequenceFormat_e;
</b></pre><BR>
<pre><b></b><p> Generate sequences using ZSTD_compress2, given a source buffer.

 Each block will end with a dummy sequence
 with offset == 0, matchLength == 0, and litLength == length of last literals.
 litLength may be == 0, and if so, then the sequence of (of: 0 ml: 0 ll: 0)
 simply acts as a block delimiter.

 zc can be used to insert custom compression params.
 This function invokes ZSTD_compress2

 The output of this function can be fed into ZSTD_compressSequences() with CCtx
 setting of ZSTD_c_blockDelimiters as ZSTD_sf_explicitBlockDelimiters
 @return : number of sequences generated

</p></pre><BR>

<pre><b>size_t ZSTD_mergeBlockDelimiters(ZSTD_Sequence* sequences, size_t seqsSize);
</b><p> Given an array of ZSTD_Sequence, remove all sequences that represent block delimiters/last literals
 by merging them into into the literals of the next sequence.

 As such, the final generated result has no explicit representation of block boundaries,
 and the final last literals segment is not represented in the sequences.

 The output of this function can be fed into ZSTD_compressSequences() with CCtx
 setting of ZSTD_c_blockDelimiters as ZSTD_sf_noBlockDelimiters
 @return : number of sequences left after merging

</p></pre><BR>

<pre><b>size_t ZSTD_compressSequences(ZSTD_CCtx* const cctx, void* dst, size_t dstSize,
                      const ZSTD_Sequence* inSeqs, size_t inSeqsSize,
                      const void* src, size_t srcSize);
</b><p> Compress an array of ZSTD_Sequence, generated from the original source buffer, into dst.
 If a dictionary is included, then the cctx should reference the dict. (see: ZSTD_CCtx_refCDict(), ZSTD_CCtx_loadDictionary(), etc.)
 The entire source is compressed into a single frame.

 The compression behavior changes based on cctx params. In particular:
    If ZSTD_c_blockDelimiters == ZSTD_sf_noBlockDelimiters, the array of ZSTD_Sequence is expected to contain
    no block delimiters (defined in ZSTD_Sequence). Block boundaries are roughly determined based on
    the block size derived from the cctx, and sequences may be split. This is the default setting.

    If ZSTD_c_blockDelimiters == ZSTD_sf_explicitBlockDelimiters, the array of ZSTD_Sequence is expected to contain
    block delimiters (defined in ZSTD_Sequence). Behavior is undefined if no block delimiters are provided.

    If ZSTD_c_validateSequences == 0, this function will blindly accept the sequences provided. Invalid sequences cause undefined
    behavior. If ZSTD_c_validateSequences == 1, then if sequence is invalid (see doc/zstd_compression_format.md for
    specifics regarding offset/matchlength requirements) then the function will bail out and return an error.

    In addition to the two adjustable experimental params, there are other important cctx params.
    - ZSTD_c_minMatch MUST be set as less than or equal to the smallest match generated by the match finder. It has a minimum value of ZSTD_MINMATCH_MIN.
    - ZSTD_c_compressionLevel accordingly adjusts the strength of the entropy coder, as it would in typical compression.
    - ZSTD_c_windowLog affects offset validation: this function will return an error at higher debug levels if a provided offset
      is larger than what the spec allows for a given window log and dictionary (if present). See: doc/zstd_compression_format.md

 Note: Repcodes are, as of now, always re-calculated within this function, so ZSTD_Sequence::rep is unused.
 Note 2: Once we integrate ability to ingest repcodes, the explicit block delims mode must respect those repcodes exactly,
         and cannot emit an RLE block that disagrees with the repcode history
 @return : final compressed size or a ZSTD error.

</p></pre><BR>

<a name="Chapter16"></a><h2>内存管理</h2><pre></pre>

<pre><b>size_t ZSTD_estimateCCtxSize(int compressionLevel);
size_t ZSTD_estimateCCtxSize_usingCParams(ZSTD_compressionParameters cParams);
size_t ZSTD_estimateCCtxSize_usingCCtxParams(const ZSTD_CCtx_params* params);
size_t ZSTD_estimateDCtxSize(void);
</b><p>  These functions make it possible to estimate memory usage
  of a future {D,C}Ctx, before its creation.

  ZSTD_estimateCCtxSize() will provide a memory budget large enough
  for any compression level up to selected one.
  Note : Unlike ZSTD_estimateCStreamSize*(), this estimate
         does not include space for a window buffer.
         Therefore, the estimation is only guaranteed for single-shot compressions, not streaming.
  The estimate will assume the input may be arbitrarily large,
  which is the worst case.

  When srcSize can be bound by a known and rather "small" value,
  this fact can be used to provide a tighter estimation
  because the CCtx compression context will need less memory.
  This tighter estimation can be provided by more advanced functions
  ZSTD_estimateCCtxSize_usingCParams(), which can be used in tandem with ZSTD_getCParams(),
  and ZSTD_estimateCCtxSize_usingCCtxParams(), which can be used in tandem with ZSTD_CCtxParams_setParameter().
  Both can be used to estimate memory using custom compression parameters and arbitrary srcSize limits.

  Note 2 : only single-threaded compression is supported.
  ZSTD_estimateCCtxSize_usingCCtxParams() will return an error code if ZSTD_c_nbWorkers is >= 1.

</p></pre><BR>

<pre><b>size_t ZSTD_estimateCStreamSize(int compressionLevel);
size_t ZSTD_estimateCStreamSize_usingCParams(ZSTD_compressionParameters cParams);
size_t ZSTD_estimateCStreamSize_usingCCtxParams(const ZSTD_CCtx_params* params);
size_t ZSTD_estimateDStreamSize(size_t windowSize);
size_t ZSTD_estimateDStreamSize_fromFrame(const void* src, size_t srcSize);
</b><p>  ZSTD_estimateCStreamSize() will provide a budget large enough for any compression level up to selected one.
  It will also consider src size to be arbitrarily "large", which is worst case.
  If srcSize is known to always be small, ZSTD_estimateCStreamSize_usingCParams() can provide a tighter estimation.
  ZSTD_estimateCStreamSize_usingCParams() can be used in tandem with ZSTD_getCParams() to create cParams from compressionLevel.
  ZSTD_estimateCStreamSize_usingCCtxParams() can be used in tandem with ZSTD_CCtxParams_setParameter(). Only single-threaded compression is supported. This function will return an error code if ZSTD_c_nbWorkers is >= 1.
  Note : CStream size estimation is only correct for single-threaded compression.
  ZSTD_DStream memory budget depends on window Size.
  This information can be passed manually, using ZSTD_estimateDStreamSize,
  or deducted from a valid frame Header, using ZSTD_estimateDStreamSize_fromFrame();
  Note : if streaming is init with function ZSTD_init?Stream_usingDict(),
         an internal ?Dict will be created, which additional size is not estimated here.
         In this case, get total size by adding ZSTD_estimate?DictSize
</p></pre><BR>

<pre><b>size_t ZSTD_estimateCDictSize(size_t dictSize, int compressionLevel);
size_t ZSTD_estimateCDictSize_advanced(size_t dictSize, ZSTD_compressionParameters cParams, ZSTD_dictLoadMethod_e dictLoadMethod);
size_t ZSTD_estimateDDictSize(size_t dictSize, ZSTD_dictLoadMethod_e dictLoadMethod);
</b><p>  ZSTD_estimateCDictSize() will bet that src size is relatively "small", and content is copied, like ZSTD_createCDict().
  ZSTD_estimateCDictSize_advanced() makes it possible to control compression parameters precisely, like ZSTD_createCDict_advanced().
  Note : dictionaries created by reference (`ZSTD_dlm_byRef`) are logically smaller.

</p></pre><BR>

<pre><b>ZSTD_CCtx*    ZSTD_initStaticCCtx(void* workspace, size_t workspaceSize);
ZSTD_CStream* ZSTD_initStaticCStream(void* workspace, size_t workspaceSize);    </b>/**< same as ZSTD_initStaticCCtx() */<b>
</b><p>  Initialize an object using a pre-allocated fixed-size buffer.
  workspace: The memory area to emplace the object into.
             Provided pointer *must be 8-bytes aligned*.
             Buffer must outlive object.
  workspaceSize: Use ZSTD_estimate*Size() to determine
                 how large workspace must be to support target scenario.
 @return : pointer to object (same address as workspace, just different type),
           or NULL if error (size too small, incorrect alignment, etc.)
  Note : zstd will never resize nor malloc() when using a static buffer.
         If the object requires more memory than available,
         zstd will just error out (typically ZSTD_error_memory_allocation).
  Note 2 : there is no corresponding "free" function.
           Since workspace is allocated externally, it must be freed externally too.
  Note 3 : cParams : use ZSTD_getCParams() to convert a compression level
           into its associated cParams.
  Limitation 1 : currently not compatible with internal dictionary creation, triggered by
                 ZSTD_CCtx_loadDictionary(), ZSTD_initCStream_usingDict() or ZSTD_initDStream_usingDict().
  Limitation 2 : static cctx currently not compatible with multi-threading.
  Limitation 3 : static dctx is incompatible with legacy support.

</p></pre><BR>

<pre><b>ZSTD_DStream* ZSTD_initStaticDStream(void* workspace, size_t workspaceSize);    </b>/**< same as ZSTD_initStaticDCtx() */<b>
</b></pre><BR>
<pre><b>typedef void* (*ZSTD_allocFunction) (void* opaque, size_t size);
typedef void  (*ZSTD_freeFunction) (void* opaque, void* address);
typedef struct { ZSTD_allocFunction customAlloc; ZSTD_freeFunction customFree; void* opaque; } ZSTD_customMem;
static
#ifdef __GNUC__
__attribute__((__unused__))
#endif
ZSTD_customMem const ZSTD_defaultCMem = { NULL, NULL, NULL };  </b>/**< this constant defers to stdlib's functions */<b>
</b><p>  These prototypes make it possible to pass your own allocation/free functions.
  ZSTD_customMem is provided at creation time, using ZSTD_create*_advanced() variants listed below.
  All allocation/free operations will be completed using these custom variants instead of regular <stdlib.h> ones.

</p></pre><BR>

<a name="Chapter17"></a><h2>高级压缩函数</h2><pre></pre>

<pre><b>ZSTD_CDict* ZSTD_createCDict_byReference(const void* dictBuffer, size_t dictSize, int compressionLevel);
</b><p>  Create a digested dictionary for compression
  Dictionary content is just referenced, not duplicated.
  As a consequence, `dictBuffer` **must** outlive CDict,
  and its content must remain unmodified throughout the lifetime of CDict.
  note: equivalent to ZSTD_createCDict_advanced(), with dictLoadMethod==ZSTD_dlm_byRef
</p></pre><BR>

<pre><b>unsigned ZSTD_getDictID_fromCDict(const ZSTD_CDict* cdict);
</b><p>  Provides the dictID of the dictionary loaded into `cdict`.
  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
  Non-conformant dictionaries can still be loaded, but as content-only dictionaries.
</p></pre><BR>

<pre><b>ZSTD_compressionParameters ZSTD_getCParams(int compressionLevel, unsigned long long estimatedSrcSize, size_t dictSize);
</b><p> @return ZSTD_compressionParameters structure for a selected compression level and estimated srcSize.
 `estimatedSrcSize` value is optional, select 0 if not known
</p></pre><BR>

<pre><b>ZSTD_parameters ZSTD_getParams(int compressionLevel, unsigned long long estimatedSrcSize, size_t dictSize);
</b><p>  same as ZSTD_getCParams(), but @return a full `ZSTD_parameters` object instead of sub-component `ZSTD_compressionParameters`.
  All fields of `ZSTD_frameParameters` are set to default : contentSize=1, checksum=0, noDictID=0
</p></pre><BR>

<pre><b>size_t ZSTD_checkCParams(ZSTD_compressionParameters params);
</b><p>  Ensure param values remain within authorized range.
 @return 0 on success, or an error code (can be checked with ZSTD_isError())
</p></pre><BR>

<pre><b>ZSTD_compressionParameters ZSTD_adjustCParams(ZSTD_compressionParameters cPar, unsigned long long srcSize, size_t dictSize);
</b><p>  optimize params for a given `srcSize` and `dictSize`.
 `srcSize` can be unknown, in which case use ZSTD_CONTENTSIZE_UNKNOWN.
 `dictSize` must be `0` when there is no dictionary.
  cPar can be invalid : all parameters will be clamped within valid range in the @return struct.
  This function never fails (wide contract)
</p></pre><BR>

<pre><b>size_t ZSTD_compress_advanced(ZSTD_CCtx* cctx,
                              void* dst, size_t dstCapacity,
                        const void* src, size_t srcSize,
                        const void* dict,size_t dictSize,
                              ZSTD_parameters params);
</b><p>  Note : this function is now DEPRECATED.
         It can be replaced by ZSTD_compress2(), in combination with ZSTD_CCtx_setParameter() and other parameter setters.
  This prototype will be marked as deprecated and generate compilation warning on reaching v1.5.x
</p></pre><BR>

<pre><b>size_t ZSTD_compress_usingCDict_advanced(ZSTD_CCtx* cctx,
                                  void* dst, size_t dstCapacity,
                            const void* src, size_t srcSize,
                            const ZSTD_CDict* cdict,
                                  ZSTD_frameParameters fParams);
</b><p>  Note : this function is now REDUNDANT.
         It can be replaced by ZSTD_compress2(), in combination with ZSTD_CCtx_loadDictionary() and other parameter setters.
  This prototype will be marked as deprecated and generate compilation warning in some future version
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_loadDictionary_byReference(ZSTD_CCtx* cctx, const void* dict, size_t dictSize);
</b><p>  Same as ZSTD_CCtx_loadDictionary(), but dictionary content is referenced, instead of being copied into CCtx.
  It saves some memory, but also requires that `dict` outlives its usage within `cctx`
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_loadDictionary_advanced(ZSTD_CCtx* cctx, const void* dict, size_t dictSize, ZSTD_dictLoadMethod_e dictLoadMethod, ZSTD_dictContentType_e dictContentType);
</b><p>  Same as ZSTD_CCtx_loadDictionary(), but gives finer control over
  how to load the dictionary (by copy ? by reference ?)
  and how to interpret it (automatic ? force raw mode ? full mode only ?)
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_refPrefix_advanced(ZSTD_CCtx* cctx, const void* prefix, size_t prefixSize, ZSTD_dictContentType_e dictContentType);
</b><p>  Same as ZSTD_CCtx_refPrefix(), but gives finer control over
  how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?)
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_getParameter(ZSTD_CCtx* cctx, ZSTD_cParameter param, int* value);
</b><p>  Get the requested compression parameter value, selected by enum ZSTD_cParameter,
  and store it into int* value.
 @return : 0, or an error code (which can be tested with ZSTD_isError()).

</p></pre><BR>

<pre><b>ZSTD_CCtx_params* ZSTD_createCCtxParams(void);
size_t ZSTD_freeCCtxParams(ZSTD_CCtx_params* params);
</b><p>  Quick howto :
  - ZSTD_createCCtxParams() : Create a ZSTD_CCtx_params structure
  - ZSTD_CCtxParams_setParameter() : Push parameters one by one into
                                     an existing ZSTD_CCtx_params structure.
                                     This is similar to
                                     ZSTD_CCtx_setParameter().
  - ZSTD_CCtx_setParametersUsingCCtxParams() : Apply parameters to
                                    an existing CCtx.
                                    These parameters will be applied to
                                    all subsequent frames.
  - ZSTD_compressStream2() : Do compression using the CCtx.
  - ZSTD_freeCCtxParams() : Free the memory.

  This can be used with ZSTD_estimateCCtxSize_advanced_usingCCtxParams()
  for static allocation of CCtx for single-threaded compression.

</p></pre><BR>

<pre><b>size_t ZSTD_CCtxParams_reset(ZSTD_CCtx_params* params);
</b><p>  Reset params to default values.

</p></pre><BR>

<pre><b>size_t ZSTD_CCtxParams_init(ZSTD_CCtx_params* cctxParams, int compressionLevel);
</b><p>  Initializes the compression parameters of cctxParams according to
  compression level. All other parameters are reset to their default values.

</p></pre><BR>

<pre><b>size_t ZSTD_CCtxParams_init_advanced(ZSTD_CCtx_params* cctxParams, ZSTD_parameters params);
</b><p>  Initializes the compression and frame parameters of cctxParams according to
  params. All other parameters are reset to their default values.

</p></pre><BR>

<pre><b>size_t ZSTD_CCtxParams_setParameter(ZSTD_CCtx_params* params, ZSTD_cParameter param, int value);
</b><p>  Similar to ZSTD_CCtx_setParameter.
  Set one compression parameter, selected by enum ZSTD_cParameter.
  Parameters must be applied to a ZSTD_CCtx using
  ZSTD_CCtx_setParametersUsingCCtxParams().
 @result : a code representing success or failure (which can be tested with
           ZSTD_isError()).

</p></pre><BR>

<pre><b>size_t ZSTD_CCtxParams_getParameter(ZSTD_CCtx_params* params, ZSTD_cParameter param, int* value);
</b><p> Similar to ZSTD_CCtx_getParameter.
 Get the requested value of one compression parameter, selected by enum ZSTD_cParameter.
 @result : 0, or an error code (which can be tested with ZSTD_isError()).

</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_setParametersUsingCCtxParams(
        ZSTD_CCtx* cctx, const ZSTD_CCtx_params* params);
</b><p>  Apply a set of ZSTD_CCtx_params to the compression context.
  This can be done even after compression is started,
    if nbWorkers==0, this will have no impact until a new compression is started.
    if nbWorkers>=1, new parameters will be picked up at next job,
       with a few restrictions (windowLog, pledgedSrcSize, nbWorkers, jobSize, and overlapLog are not updated).

</p></pre><BR>

<pre><b>size_t ZSTD_compressStream2_simpleArgs (
                ZSTD_CCtx* cctx,
                void* dst, size_t dstCapacity, size_t* dstPos,
          const void* src, size_t srcSize, size_t* srcPos,
                ZSTD_EndDirective endOp);
</b><p>  Same as ZSTD_compressStream2(),
  but using only integral types as arguments.
  This variant might be helpful for binders from dynamic languages
  which have troubles handling structures containing memory pointers.

</p></pre><BR>

<a name="Chapter18"></a><h2>高级解压函数</h2><pre></pre>

<pre><b>unsigned ZSTD_isFrame(const void* buffer, size_t size);
</b><p>  Tells if the content of `buffer` starts with a valid Frame Identifier.
  Note : Frame Identifier is 4 bytes. If `size < 4`, @return will always be 0.
  Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled.
  Note 3 : Skippable Frame Identifiers are considered valid.
</p></pre><BR>

<pre><b>ZSTD_DDict* ZSTD_createDDict_byReference(const void* dictBuffer, size_t dictSize);
</b><p>  Create a digested dictionary, ready to start decompression operation without startup delay.
  Dictionary content is referenced, and therefore stays in dictBuffer.
  It is important that dictBuffer outlives DDict,
  it must remain read accessible throughout the lifetime of DDict
</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_loadDictionary_byReference(ZSTD_DCtx* dctx, const void* dict, size_t dictSize);
</b><p>  Same as ZSTD_DCtx_loadDictionary(),
  but references `dict` content instead of copying it into `dctx`.
  This saves memory if `dict` remains around.,
  However, it's imperative that `dict` remains accessible (and unmodified) while being used, so it must outlive decompression.
</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_loadDictionary_advanced(ZSTD_DCtx* dctx, const void* dict, size_t dictSize, ZSTD_dictLoadMethod_e dictLoadMethod, ZSTD_dictContentType_e dictContentType);
</b><p>  Same as ZSTD_DCtx_loadDictionary(),
  but gives direct control over
  how to load the dictionary (by copy ? by reference ?)
  and how to interpret it (automatic ? force raw mode ? full mode only ?).
</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_refPrefix_advanced(ZSTD_DCtx* dctx, const void* prefix, size_t prefixSize, ZSTD_dictContentType_e dictContentType);
</b><p>  Same as ZSTD_DCtx_refPrefix(), but gives finer control over
  how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?)
</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_setMaxWindowSize(ZSTD_DCtx* dctx, size_t maxWindowSize);
</b><p>  Refuses allocating internal buffers for frames requiring a window size larger than provided limit.
  This protects a decoder context from reserving too much memory for itself (potential attack scenario).
  This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode.
  By default, a decompression context accepts all window sizes <= (1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT)
 @return : 0, or an error code (which can be tested using ZSTD_isError()).

</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_getParameter(ZSTD_DCtx* dctx, ZSTD_dParameter param, int* value);
</b><p>  Get the requested decompression parameter value, selected by enum ZSTD_dParameter,
  and store it into int* value.
 @return : 0, or an error code (which can be tested with ZSTD_isError()).

</p></pre><BR>

<pre><b>size_t ZSTD_DCtx_setFormat(ZSTD_DCtx* dctx, ZSTD_format_e format);
</b><p>  Instruct the decoder context about what kind of data to decode next.
  This instruction is mandatory to decode data without a fully-formed header,
  such ZSTD_f_zstd1_magicless for example.
 @return : 0, or an error code (which can be tested using ZSTD_isError()).
</p></pre><BR>

<pre><b>size_t ZSTD_decompressStream_simpleArgs (
                ZSTD_DCtx* dctx,
                void* dst, size_t dstCapacity, size_t* dstPos,
          const void* src, size_t srcSize, size_t* srcPos);
</b><p>  Same as ZSTD_decompressStream(),
  but using only integral types as arguments.
  This can be helpful for binders from dynamic languages
  which have troubles handling structures containing memory pointers.

</p></pre><BR>

<a name="Chapter19"></a><h2>高级数据流函数</h2><pre>  Warning : most of these functions are now redundant with the Advanced API.
  Once Advanced API reaches "stable" status,
  redundant functions will be deprecated, and then at some point removed.
<BR></pre>

<h3>高级数据流压缩函数</h3><pre></pre><b><pre></pre></b><BR>
<pre><b>size_t
ZSTD_initCStream_srcSize(ZSTD_CStream* zcs,
             int compressionLevel,
             unsigned long long pledgedSrcSize);
</b><p> This function is deprecated, and equivalent to:
     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)
     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);

 pledgedSrcSize must be correct. If it is not known at init time, use
 ZSTD_CONTENTSIZE_UNKNOWN. Note that, for compatibility with older programs,
 "0" also disables frame content size field. It may be enabled in the future.
 Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x

</p></pre><BR>

<pre><b>size_t
ZSTD_initCStream_usingDict(ZSTD_CStream* zcs,
         const void* dict, size_t dictSize,
               int compressionLevel);
</b><p> This function is deprecated, and is equivalent to:
     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
     ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);

 Creates of an internal CDict (incompatible with static CCtx), except if
 dict == NULL or dictSize < 8, in which case no dict is used.
 Note: dict is loaded with ZSTD_dct_auto (treated as a full zstd dictionary if
 it begins with ZSTD_MAGIC_DICTIONARY, else as raw content) and ZSTD_dlm_byCopy.
 Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x

</p></pre><BR>

<pre><b>size_t
ZSTD_initCStream_advanced(ZSTD_CStream* zcs,
        const void* dict, size_t dictSize,
              ZSTD_parameters params,
              unsigned long long pledgedSrcSize);
</b><p> This function is deprecated, and is approximately equivalent to:
     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
     // Pseudocode: Set each zstd parameter and leave the rest as-is.
     for ((param, value) : params) {
         ZSTD_CCtx_setParameter(zcs, param, value);
     }
     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
     ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);

 dict is loaded with ZSTD_dct_auto and ZSTD_dlm_byCopy.
 pledgedSrcSize must be correct.
 If srcSize is not known at init time, use value ZSTD_CONTENTSIZE_UNKNOWN.
 Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x

</p></pre><BR>

<pre><b>size_t ZSTD_initCStream_usingCDict(ZSTD_CStream* zcs, const ZSTD_CDict* cdict);
</b><p> This function is deprecated, and equivalent to:
     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
     ZSTD_CCtx_refCDict(zcs, cdict);

 note : cdict will just be referenced, and must outlive compression session
 Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x

</p></pre><BR>

<pre><b>size_t
ZSTD_initCStream_usingCDict_advanced(ZSTD_CStream* zcs,
                   const ZSTD_CDict* cdict,
                         ZSTD_frameParameters fParams,
                         unsigned long long pledgedSrcSize);
</b><p>   This function is DEPRECATED, and is approximately equivalent to:
     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
     // Pseudocode: Set each zstd frame parameter and leave the rest as-is.
     for ((fParam, value) : fParams) {
         ZSTD_CCtx_setParameter(zcs, fParam, value);
     }
     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
     ZSTD_CCtx_refCDict(zcs, cdict);

 same as ZSTD_initCStream_usingCDict(), with control over frame parameters.
 pledgedSrcSize must be correct. If srcSize is not known at init time, use
 value ZSTD_CONTENTSIZE_UNKNOWN.
 Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x

</p></pre><BR>

<pre><b>size_t ZSTD_resetCStream(ZSTD_CStream* zcs, unsigned long long pledgedSrcSize);
</b><p> This function is deprecated, and is equivalent to:
     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);

  start a new frame, using same parameters from previous frame.
  This is typically useful to skip dictionary loading stage, since it will re-use it in-place.
  Note that zcs must be init at least once before using ZSTD_resetCStream().
  If pledgedSrcSize is not known at reset time, use macro ZSTD_CONTENTSIZE_UNKNOWN.
  If pledgedSrcSize > 0, its value must be correct, as it will be written in header, and controlled at the end.
  For the time being, pledgedSrcSize==0 is interpreted as "srcSize unknown" for compatibility with older programs,
  but it will change to mean "empty" in future version, so use macro ZSTD_CONTENTSIZE_UNKNOWN instead.
 @return : 0, or an error code (which can be tested using ZSTD_isError())
  Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x

</p></pre><BR>

<pre><b>typedef struct {
    unsigned long long ingested;   </b>/* nb input bytes read and buffered */<b>
    unsigned long long consumed;   </b>/* nb input bytes actually compressed */<b>
    unsigned long long produced;   </b>/* nb of compressed bytes generated and buffered */<b>
    unsigned long long flushed;    </b>/* nb of compressed bytes flushed : not provided; can be tracked from caller side */<b>
    unsigned currentJobID;         </b>/* MT only : latest started job nb */<b>
    unsigned nbActiveWorkers;      </b>/* MT only : nb of workers actively compressing at probe time */<b>
} ZSTD_frameProgression;
</b></pre><BR>
<pre><b>size_t ZSTD_toFlushNow(ZSTD_CCtx* cctx);
</b><p>  Tell how many bytes are ready to be flushed immediately.
  Useful for multithreading scenarios (nbWorkers >= 1).
  Probe the oldest active job, defined as oldest job not yet entirely flushed,
  and check its output buffer.
 @return : amount of data stored in oldest job and ready to be flushed immediately.
  if @return == 0, it means either :
  + there is no active job (could be checked with ZSTD_frameProgression()), or
  + oldest job is still actively compressing data,
    but everything it has produced has also been flushed so far,
    therefore flush speed is limited by production speed of oldest job
    irrespective of the speed of concurrent (and newer) jobs.

</p></pre><BR>

<h3>高级数据流解压函数</h3><pre></pre><b><pre></pre></b><BR>
<pre><b>size_t ZSTD_initDStream_usingDict(ZSTD_DStream* zds, const void* dict, size_t dictSize);
</b><p>
     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
     ZSTD_DCtx_loadDictionary(zds, dict, dictSize);

 note: no dictionary will be used if dict == NULL or dictSize < 8
 Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x

</p></pre><BR>

<pre><b>size_t ZSTD_initDStream_usingDDict(ZSTD_DStream* zds, const ZSTD_DDict* ddict);
</b><p>
     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
     ZSTD_DCtx_refDDict(zds, ddict);

 note : ddict is referenced, it must outlive decompression session
 Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x

</p></pre><BR>

<pre><b>size_t ZSTD_resetDStream(ZSTD_DStream* zds);
</b><p>
     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);

 re-use decompression parameters from previous init; saves dictionary loading
 Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x

</p></pre><BR>

<a name="Chapter20"></a><h2>无缓冲区和同步的内部数据流函数</h2><pre>
  This is an advanced API, giving full control over buffer management, for users which need direct control over memory.
  But it's also a complex one, with several restrictions, documented below.
  Prefer normal streaming API for an easier experience.

<BR></pre>

<a name="Chapter21"></a><h2>无缓冲区数据流压缩 (同步模式)</h2><pre>
  A ZSTD_CCtx object is required to track streaming operations.
  Use ZSTD_createCCtx() / ZSTD_freeCCtx() to manage resource.
  ZSTD_CCtx object can be re-used multiple times within successive compression operations.

  Start by initializing a context.
  Use ZSTD_compressBegin(), or ZSTD_compressBegin_usingDict() for dictionary compression,
  or ZSTD_compressBegin_advanced(), for finer parameter control.
  It's also possible to duplicate a reference context which has already been initialized, using ZSTD_copyCCtx()

  Then, consume your input using ZSTD_compressContinue().
  There are some important considerations to keep in mind when using this advanced function :
  - ZSTD_compressContinue() has no internal buffer. It uses externally provided buffers only.
  - Interface is synchronous : input is consumed entirely and produces 1+ compressed blocks.
  - Caller must ensure there is enough space in `dst` to store compressed data under worst case scenario.
    Worst case evaluation is provided by ZSTD_compressBound().
    ZSTD_compressContinue() doesn't guarantee recover after a failed compression.
  - ZSTD_compressContinue() presumes prior input ***is still accessible and unmodified*** (up to maximum distance size, see WindowLog).
    It remembers all previous contiguous blocks, plus one separated memory segment (which can itself consists of multiple contiguous blocks)
  - ZSTD_compressContinue() detects that prior input has been overwritten when `src` buffer overlaps.
    In which case, it will "discard" the relevant memory section from its history.

  Finish a frame with ZSTD_compressEnd(), which will write the last block(s) and optional checksum.
  It's possible to use srcSize==0, in which case, it will write a final empty block to end the frame.
  Without last block mark, frames are considered unfinished (hence corrupted) by compliant decoders.

  `ZSTD_CCtx` object can be re-used (ZSTD_compressBegin()) to compress again.
<BR></pre>

<h3>Buffer-less streaming compression functions</h3><pre></pre><b><pre>size_t ZSTD_compressBegin(ZSTD_CCtx* cctx, int compressionLevel);
size_t ZSTD_compressBegin_usingDict(ZSTD_CCtx* cctx, const void* dict, size_t dictSize, int compressionLevel);
size_t ZSTD_compressBegin_advanced(ZSTD_CCtx* cctx, const void* dict, size_t dictSize, ZSTD_parameters params, unsigned long long pledgedSrcSize); </b>/**< pledgedSrcSize : If srcSize is not known at init time, use ZSTD_CONTENTSIZE_UNKNOWN */<b>
size_t ZSTD_compressBegin_usingCDict(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict); </b>/**< note: fails if cdict==NULL */<b>
size_t ZSTD_compressBegin_usingCDict_advanced(ZSTD_CCtx* const cctx, const ZSTD_CDict* const cdict, ZSTD_frameParameters const fParams, unsigned long long const pledgedSrcSize);   </b>/* compression parameters are already set within cdict. pledgedSrcSize must be correct. If srcSize is not known, use macro ZSTD_CONTENTSIZE_UNKNOWN */<b>
size_t ZSTD_copyCCtx(ZSTD_CCtx* cctx, const ZSTD_CCtx* preparedCCtx, unsigned long long pledgedSrcSize); </b>/**<  note: if pledgedSrcSize is not known, use ZSTD_CONTENTSIZE_UNKNOWN */<b>
</pre></b><BR>
<a name="Chapter22"></a><h2>无缓冲区数据流解压 (同步模式)</h2><pre>
  A ZSTD_DCtx object is required to track streaming operations.
  Use ZSTD_createDCtx() / ZSTD_freeDCtx() to manage it.
  A ZSTD_DCtx object can be re-used multiple times.

  First typical operation is to retrieve frame parameters, using ZSTD_getFrameHeader().
  Frame header is extracted from the beginning of compressed frame, so providing only the frame's beginning is enough.
  Data fragment must be large enough to ensure successful decoding.
 `ZSTD_frameHeaderSize_max` bytes is guaranteed to always be large enough.
  @result : 0 : successful decoding, the `ZSTD_frameHeader` structure is correctly filled.
           >0 : `srcSize` is too small, please provide at least @result bytes on next attempt.
           errorCode, which can be tested using ZSTD_isError().

  It fills a ZSTD_frameHeader structure with important information to correctly decode the frame,
  such as the dictionary ID, content size, or maximum back-reference distance (`windowSize`).
  Note that these values could be wrong, either because of data corruption, or because a 3rd party deliberately spoofs false information.
  As a consequence, check that values remain within valid application range.
  For example, do not allocate memory blindly, check that `windowSize` is within expectation.
  Each application can set its own limits, depending on local restrictions.
  For extended interoperability, it is recommended to support `windowSize` of at least 8 MB.

  ZSTD_decompressContinue() needs previous data blocks during decompression, up to `windowSize` bytes.
  ZSTD_decompressContinue() is very sensitive to contiguity,
  if 2 blocks don't follow each other, make sure that either the compressor breaks contiguity at the same place,
  or that previous contiguous segment is large enough to properly handle maximum back-reference distance.
  There are multiple ways to guarantee this condition.

  The most memory efficient way is to use a round buffer of sufficient size.
  Sufficient size is determined by invoking ZSTD_decodingBufferSize_min(),
  which can @return an error code if required value is too large for current system (in 32-bits mode).
  In a round buffer methodology, ZSTD_decompressContinue() decompresses each block next to previous one,
  up to the moment there is not enough room left in the buffer to guarantee decoding another full block,
  which maximum size is provided in `ZSTD_frameHeader` structure, field `blockSizeMax`.
  At which point, decoding can resume from the beginning of the buffer.
  Note that already decoded data stored in the buffer should be flushed before being overwritten.

  There are alternatives possible, for example using two or more buffers of size `windowSize` each, though they consume more memory.

  Finally, if you control the compression process, you can also ignore all buffer size rules,
  as long as the encoder and decoder progress in "lock-step",
  aka use exactly the same buffer sizes, break contiguity at the same place, etc.

  Once buffers are setup, start decompression, with ZSTD_decompressBegin().
  If decompression requires a dictionary, use ZSTD_decompressBegin_usingDict() or ZSTD_decompressBegin_usingDDict().

  Then use ZSTD_nextSrcSizeToDecompress() and ZSTD_decompressContinue() alternatively.
  ZSTD_nextSrcSizeToDecompress() tells how many bytes to provide as 'srcSize' to ZSTD_decompressContinue().
  ZSTD_decompressContinue() requires this _exact_ amount of bytes, or it will fail.

 @result of ZSTD_decompressContinue() is the number of bytes regenerated within 'dst' (necessarily <= dstCapacity).
  It can be zero : it just means ZSTD_decompressContinue() has decoded some metadata item.
  It can also be an error code, which can be tested with ZSTD_isError().

  A frame is fully decoded when ZSTD_nextSrcSizeToDecompress() returns zero.
  Context can then be reset to start a new decompression.

  Note : it's possible to know if next input to present is a header or a block, using ZSTD_nextInputType().
  This information is not required to properly decode a frame.

  == Special case : skippable frames

  Skippable frames allow integration of user-defined data into a flow of concatenated frames.
  Skippable frames will be ignored (skipped) by decompressor.
  The format of skippable frames is as follows :
  a) Skippable frame ID - 4 Bytes, Little endian format, any value from 0x184D2A50 to 0x184D2A5F
  b) Frame Size - 4 Bytes, Little endian format, unsigned 32-bits
  c) Frame Content - any content (User Data) of length equal to Frame Size
  For skippable frames ZSTD_getFrameHeader() returns zfhPtr->frameType==ZSTD_skippableFrame.
  For skippable frames ZSTD_decompressContinue() always returns 0 : it only skips the content.
<BR></pre>

<h3>Buffer-less streaming decompression functions</h3><pre></pre><b><pre>typedef enum { ZSTD_frame, ZSTD_skippableFrame } ZSTD_frameType_e;
typedef struct {
    unsigned long long frameContentSize; </b>/* if == ZSTD_CONTENTSIZE_UNKNOWN, it means this field is not available. 0 means "empty" */<b>
    unsigned long long windowSize;       </b>/* can be very large, up to <= frameContentSize */<b>
    unsigned blockSizeMax;
    ZSTD_frameType_e frameType;          </b>/* if == ZSTD_skippableFrame, frameContentSize is the size of skippable content */<b>
    unsigned headerSize;
    unsigned dictID;
    unsigned checksumFlag;
} ZSTD_frameHeader;
</pre></b><BR>
<pre><b>size_t ZSTD_getFrameHeader(ZSTD_frameHeader* zfhPtr, const void* src, size_t srcSize);   </b>/**< doesn't consume input */<b>
</b>/*! ZSTD_getFrameHeader_advanced() :<b>
 *  same as ZSTD_getFrameHeader(),
 *  with added capability to select a format (like ZSTD_f_zstd1_magicless) */
size_t ZSTD_getFrameHeader_advanced(ZSTD_frameHeader* zfhPtr, const void* src, size_t srcSize, ZSTD_format_e format);
size_t ZSTD_decodingBufferSize_min(unsigned long long windowSize, unsigned long long frameContentSize);  </b>/**< when frame content size is not known, pass in frameContentSize == ZSTD_CONTENTSIZE_UNKNOWN */<b>
</b><p>  decode Frame Header, or requires larger `srcSize`.
 @return : 0, `zfhPtr` is correctly filled,
          >0, `srcSize` is too small, value is wanted `srcSize` amount,
           or an error code, which can be tested using ZSTD_isError()
</p></pre><BR>

<pre><b>typedef enum { ZSTDnit_frameHeader, ZSTDnit_blockHeader, ZSTDnit_block, ZSTDnit_lastBlock, ZSTDnit_checksum, ZSTDnit_skippableFrame } ZSTD_nextInputType_e;
</b></pre><BR>
<a name="Chapter23"></a><h2>区块级 API</h2><pre></pre>

<pre><b></b><p>    Frame metadata cost is typically ~12 bytes, which can be non-negligible for very small blocks (< 100 bytes).
    But users will have to take in charge needed metadata to regenerate data, such as compressed and content sizes.

    A few rules to respect :
    - Compressing and decompressing require a context structure
      + Use ZSTD_createCCtx() and ZSTD_createDCtx()
    - It is necessary to init context before starting
      + compression : any ZSTD_compressBegin*() variant, including with dictionary
      + decompression : any ZSTD_decompressBegin*() variant, including with dictionary
      + copyCCtx() and copyDCtx() can be used too
    - Block size is limited, it must be <= ZSTD_getBlockSize() <= ZSTD_BLOCKSIZE_MAX == 128 KB
      + If input is larger than a block size, it's necessary to split input data into multiple blocks
      + For inputs larger than a single block, consider using regular ZSTD_compress() instead.
        Frame metadata is not that costly, and quickly becomes negligible as source size grows larger than a block.
    - When a block is considered not compressible enough, ZSTD_compressBlock() result will be 0 (zero) !
      ===> In which case, nothing is produced into `dst` !
      + User __must__ test for such outcome and deal directly with uncompressed data
      + A block cannot be declared incompressible if ZSTD_compressBlock() return value was != 0.
        Doing so would mess up with statistics history, leading to potential data corruption.
      + ZSTD_decompressBlock() _doesn't accept uncompressed data as input_ !!
      + In case of multiple successive blocks, should some of them be uncompressed,
        decoder must be informed of their existence in order to follow proper history.
        Use ZSTD_insertBlock() for such a case.
</p></pre><BR>

<h3>原始的 zstd 块函数</h3><pre></pre><b><pre>size_t ZSTD_getBlockSize   (const ZSTD_CCtx* cctx);
size_t ZSTD_compressBlock  (ZSTD_CCtx* cctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);
size_t ZSTD_decompressBlock(ZSTD_DCtx* dctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);
size_t ZSTD_insertBlock    (ZSTD_DCtx* dctx, const void* blockStart, size_t blockSize);  </b>/**< 将未压缩的块插入到 `dctx` 历史中，对多块解压有用 */<b>
</pre></b><BR>
</html>
</body>
